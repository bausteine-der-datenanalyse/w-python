# Eigene Funktionen definieren
Das Definieren eigener Funktionen eröffnet vielfältige Möglichkeiten in Python:

  - Komplexe Programme können mit einer einzigen Zeile Code aufgerufen und ausgeführt werden.

  - Funktionen können praktisch beliebig oft aufgerufen werden und sind durch den Einsatz von Parametern und Methoden der Flusskontrolle gleichzeitig in der Lage, flexibel auf wechselnde Bedingungen zu reagieren.

  - Funktionen machen Programmcode kürzer und lesbarer. Außerdem gibt es nur eine Stelle, welche bei Änderungen angepasst werden muss.

## Syntax
Das Schlüsselwort `def` leitet die Funktionsdefinition ein. Es wird gefolgt vom Funktionsnamen und den Funktionsparametern, welche in runden Klammern `()` eingeschlossen sind. Der Funktionskopf wird mit einem Doppelpunkt `:` beendet. Der Anweisungsblock der Funktion ist eingerückt. Jede Funktion liefert einen Rückgabewert, welche durch das Schlüsselwort `return` an die aufrufende Stelle zurückgegeben wird.  `return` beendet die Ausführung der Schleife, auch wenn es nicht am Ende des Anweisungsblocks steht.

``` {python}
#| output: false
def Funktionsname(Parameter1, Parameter2):
    Anweisungsblock
    return Rückgabewert
```

Damit die Funktion ausgeführt wird, muss der definierte Funktionsname aufgerufen werden. In der Funktion ist nach dem Schlüsselwort `return` eine weitere Anweisung enthalten, die nicht mehr ausgeführt wird.

```{python}
# Beispiel 1: Summe der Quadrate

# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten
def sum_quadrate(a, b):
    print('Argument a:', a)
    print('Argument b:', b)
    print(18 * '=')
    summe = a**2 + b**2
    return summe
    print("Anweisungen nach dem Schlüsselwort return werden nicht mehr ausgeführt.")

print(sum_quadrate(6, 7))
```

Der Rückgabewert kann in einer Variablen gespeichert werden.

```{python}
ergebnis = sum_quadrate(6, 7)
print(ergebnis)
```

## Optionale Parameter
Mit Hilfe von optionalen Parametern kann die Programmausführung gesteuert werden. Optionale Parameter müssen nach verpflichtend zu übergebenen Parametern definiert werden. In diesem Beispiel wird die print-Ausgabe der Funktion mit dem Parameter `ausgabe` gesteuert.

```{python}
# Beispiel 2: optionale Argumente

# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten
def sum_quadrate(a, b, ausgabe = False):
    if ausgabe:
      print('Wert Argument a:', a)
      print('Wert Argument b:', b)
      print(18 * '=')
    summe = a**2 + b**2
    return summe

print(sum_quadrate(42, 7), "\n")
print(sum_quadrate(42, 7, ausgabe = True))
```

Gibt es mehrere optionale Parameter, so erfolgt die Zuweisung von Argumenten positional oder über das Schlüsselwort.

```{python}
# Beispiel 3: mehrere optionale Argumente

# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten
def sum_potenzen(a, b, p = 2, ausgabe = False):
    if ausgabe:
      print('Argument a:', a)
      print('Argument b:', b)
      print('Argument p:', p)
      print(18 * '=')
    summe = a**p + b**p
    return summe

# positionale Übergabe
print(sum_potenzen(42, 7, 3, True), "\n")

# Übergabe per Schlüsselwort
print(sum_potenzen(42, 7, ausgabe = True, p = 4))
```

## Rückgabewert(e)
Funktionen können in Python nur einen einzigen Rückgabewert haben. Trotzdem können mehrere Rückgabewerte mit einem Komma getrennt werden. Python gibt diese als Tupel zurück.

```{python}
# Beispiel 4: mehrere Rückgabewerte

# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten
def sum_potenzen(a, b, p = 2, ausgabe = False):
    if ausgabe:
      print('Argument a:', a)
      print('Argument b:', b)
      print('Argument p:', p)
      print(18 * '=')
    summe = a**p + b**p
    return a, b, summe

ergebnis = sum_potenzen(2, 7, ausgabe = False, p = 4)
print(ergebnis, type(ergebnis))
```

Mit dem Slice Operator kann ein bestimmter Rückgabewert ausgewählt werden.

```{python}
print(ergebnis[2])

summe_potenzen = sum_potenzen(2, 7, ausgabe = False, p = 4)[2]
print(summe_potenzen, type(summe_potenzen))
```

<!-- ggf. ergänzen
## anonyme Funktionen Lambdas
<https://docs.python.org/3/reference/expressions.html#lambda> -->

## Aufgaben Funktionen definieren
1. Palindrom  
Schreiben Sie eine Funktion is_palindrome(), die prüft, ob es sich bei einer übergebenen Zeichenkette um ein Palindrom handelt.

*Hinweis: Ein Palindrom ist eine Zeichenkette, die von vorne und von hinten gelesen gleich bleibt, wie beispielsweise ‘Anna’, ‘Otto’, ‘Lagerregal’. Palindrome müssen nicht aus Buchstaben bestehen, sie können sich auch aus Zahlen oder Buchstaben und Zahlen zusammensetzen wie beispielsweise ‘345g543’.*

2. Fibonacci-Zahlenreihe

Entwickeln Sie eine Funktion fibonacci(n), die die ersten n Zahlen der Fibonacci-Reihe generiert und als Liste zurückgibt. Die Fibonacci-Reihe beginnt mit 0 und 1, jede weitere Zahl ist die Summe der beiden vorhergehenden Zahlen.

3. Verschlüsselung

Bei Geocachen werden oft verschlüsselte Botschaften als Rätsel verwendet. Oft wird folgende Logik zur Verschlüsselung angewendet:

* A -> Z

* B -> Y

* C -> X

* ...

Schreiben Sie eine Funktion `verschluesseln(str)`, die einen String als Eingabewert bekommt und einen verschlüsselten String zurückgibt. Wie können Sie einen verschlüsselten String am einfachsten wieder entschlüsseln?

4. Temperaturkonverter

Entwickeln Sie eine Funktion `temperatur_umrechnen(wert, von_einheit, nach_einheit)`, die eine Temperatur von einer Einheit in eine andere umwandelt. Die Funktion soll folgende Parameter verwenden:

  - wert: Der Temperaturwert, der umgewandelt werden soll.
  
  - von_einheit / nach_einheit: Die Einheit des Ausgangs- bzw. des Zielwerts als string. Mögliche Werte sind 'C' für Celsius, 'F' für Fahrenheit und 'K' für Kelvin.

Es gelten die folgenden Umrechnungsformeln zwischen den Einheiten:

  - Celsius nach Fahrenheit: F = C * 9/5 + 32
  
  - Fahrenheit nach Celsius: C = (F - 32) * 5/9
  
  - Celsius nach Kelvin: K = C + 273.15
  
  - Kelvin nach Celsius: C = K - 273.15
  
  - Fahrenheit nach Kelvin: K = (F - 32) * 5/9 + 273.15
  
  - Kelvin nach Fahrenheit: F = (K - 273.15) * 9/5 + 32

::: {.callout-tip collapse="true"}
## Musterlösung Aufgaben Funktionen definieren

:::: {.border}

1. Aufgabe Palindrom
```{python}
# 1.
def is_palindrome(text):
    text = text.lower()

    return text == text[::-1]

# zu prüfende Zeichenkette in dieser Variablen anlegen
xyz = "Lagerregal"
if is_palindrome(xyz) == True:
    print(f"Ja, {xyz} ist ein Palindrom")
else:
    print(f"Nein, {xyz} ist kein Palindrom")
```

2. Aufgabe Fibonacci
```{python}
# 2.
def fibonacci(n):

    # die Sonderfälle müssen beachtet werden:
    if n <= 0:
        return []
    elif n == 1:
        return [0]

    # nachdem die beiden Sonderfälle berücksichtigt wurden, sieht die Liste zum Start immer wie folgt aus:
    fibonacci_reihe = [0,1]
    
    while len(fibonacci_reihe) < n:
        naechste_zahl = fibonacci_reihe[-1] + fibonacci_reihe[-2]
        fibonacci_reihe.append(naechste_zahl)
    
    return fibonacci_reihe

fibonacci(8)
```

3. Aufgabe Verschlüsselung

::::: {.panel-tabset}
## mit Listen
```{python}
# 3.
def verschluesseln(str):

    # in sechs Variablen wird einmal das normale und einmal das umgekehrte Alphabet sowie die Ziffern 0-9 definiert
    abc = "abcdefghijklmnopqrstuvwxyz"
    abc_2 = "zyxwvutsrqponmlkjihgfedcba"
    ABC = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    ABC_2 = "ZYXWVUTSRQPONMLKJIHGFEDCBA"
    ziffern = "0123456789"
    ziffern_2 = "9876543210"

    neuer_string = ""

    for i in str:
        if i in ABC: # Großbuchstaben
            position = ABC.index(i)
            neuer_buchstabe = ABC_2[position]

            neuer_string += neuer_buchstabe
        elif i in abc: # Kleinbuchstaben
            position = abc.index(i)
            neuer_buchstabe = abc_2[position]

            neuer_string += neuer_buchstabe   
        elif i in ziffern: # Ziffern
            position = ziffern.index(i)
            neuer_buchstabe = ziffern_2[position]

            neuer_string += neuer_buchstabe                    
        else: # sonstige Zeichen werden unverändert übernommen
            neuer_string += i
    
    return neuer_string
    
# zu verschlüsselnde Nachricht:
geheime_nachricht = 'Dies ist das Geheimnis: <*)))><'
enkodierter_text = verschluesseln(geheime_nachricht)
print(enkodierter_text)

# die einfachste Möglichkeit die verschlüsselte Nachricht wieder zu entschlüsseln ist, die gleiche Funktion erneut auf die verschlüsselte Nachricht anzuwenden
dekodierter_text = verschluesseln(enkodierter_text)
print(dekodierter_text)
```

## mit ord() und chr()
```{python}
def verschluesseln(a):
    a = list(a)
    # print(a)
    b = [] # output list
    
    for i in a:
        # print(i, ord(i))
        b.append(ord(i))
    # print(b)
            
    # invertieren a = 97, z = 122, A = 65, Z = 90, 0 = 48, 9 = 57
    # Max - Wert + Min 
    
    for i in range(len(b)):
        if b[i] >= 65 and b[i] <= 90: # Großbuchstaben
            b[i] = chr(90 - b[i] + 65)
        elif b[i] >= 97 and b[i] <= 122: # Kleinbuchstaben
            b[i] = chr(122 - b[i] + 97)
        elif b[i] >= 48 and b[i] <= 57: # Zahlen
            b[i] = chr(57 - b[i] + 48) 
        else: # sonstige Zeichen
            b[i] = chr(b[i])
            
    return ''.join(b)

print(enkodierter_text)
print(verschluesseln(a = enkodierter_text))

```

:::::

4. Temperaturkonverter
```{python}
# 4.
def temperatur_umrechnen(wert, von_einheit, nach_einheit):

    # if-Abfragen um zu prüfen, welche Einheit der umzuwandelnde Wert hat. Je nachdem welcher Zweig ausgelöst wird, wird der Wert in weiteren if-Abfragen entsprechend der Zieleinheit umgerechnet
    
    # if-Abfrage für Ursprungswert in Celsius:
    if von_einheit == "C":
        if nach_einheit == "F":
            return wert * 9/5 + 32
        elif nach_einheit == "K":
            return wert + 273.15
        elif nach_einheit == "C":
            return wert
    
    # if-Abfrage für Ursprungswert in Fahrenheit:
    if von_einheit == "F":
        if nach_einheit == "C":
            return (wert - 32) * 5/9
        elif nach_einheit == "K":
            return (wert - 32) * 5/9 + 273.15
        elif nach_einheit == "F":
            return wert
    
    # if-Abfrage für Ursprungswert in Kelvin:
    if von_einheit == "K":
        if nach_einheit == "C":
            return wert - 273.15
        elif nach_einheit == "F":
            return (wert - 273.15) * 9/5 + 32
        elif nach_einheit == "K":
            return wert

    # für ungültige Einheiten wird None zurückgegeben    
    return None

test_temp = temperatur_umrechnen(37, "C", "F")
print(f"37°C sind in Fahrenheit: {test_temp}°F")
```

Musterlösung von Marc Sönnecken und Maik Poetzsch

::::
:::

&nbsp;
(@Arnold-2023-funktionen-module-dateien)