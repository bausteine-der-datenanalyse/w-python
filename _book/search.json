[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Python",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nKeine Voraussetzungen, hilfreich ist der w-Pseudocode",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nHier stehen die Lernziele",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#einleitung",
    "href": "index.html#einleitung",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Einleitung",
    "text": "Einleitung\nEinleitungstext",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "einleitung.html",
    "href": "einleitung.html",
    "title": "1  Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "Die Erzeugung und Auswertung von Daten ist ein zentraler Bestandteil wissenschaftlicher Forschung. Die computergestützte Datenanalyse ermöglicht es, große Datenmengen (teil-)automatisiert auszuwerten. Gut lesbare Skriptsprachen wie Python sorgen für eine nachvollziehbare Datenverarbeitung und ermöglichen es, Analysen “auf Knopfdruck” zu wiederholen oder anzupassen.\n\n\n\n\nLogo der Programmiersprache Python\n\n\nPython Logo von Python Software Foundation steht unter der GPLv3. Die Wort-Bild-Marke ist markenrechtlich geschützt: https://www.python.org/psf/trademarks/. Das Werk ist abrufbar auf wikimedia. 2008\n\n \nAls Skriptsprache werden Python-Programme nicht in ein fertiges Programm übersetzt, sondern von einem sogenannten Interpreter, der die Programmanweisungen in Maschinencode für das jeweilige Computersystem übersetzt, ausgeführt. Dadurch kann das Skript auf verschiedenen Computersystemen ausgeführt werden. Zwar sind interpretierte Sprachen langsamer als fertig übersetzte Programme. Bei rechenintensiven Alogrithmen helfen jedoch spezialisierte Pakete, die Rechenleistung von Python deutlich zu steigern und diesen Unterschied fast ganz auszugleichen.\nPython kommt als schlichte Konsole daher. Zahlreiche Funktionen wie Codeformatierung, Codevervollständigung und Fehleranalyse werden durch eine sogenannte integrierte Entwicklungsumgebung (integrated development environment, IDE) bereitgestellt.\n\n\n\n\n\nProgrammentwicklung mit Python\n\n\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "Python-Code.html",
    "href": "Python-Code.html",
    "title": "2  Python-Code",
    "section": "",
    "text": "2.1 Python-Code\nBei der Formatierung von Python-Code müssen nur wenige Punkte beachtet werden.\nprint(1 + 2)\nprint('Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\nHallo Welt!\nHallo Python!\n# bloß nicht übertreiben\n# print(\"Python ist großartig!\") # das ist übertrieben\nprint(\"Python ist ziemlich gut.\") # das ist realistisch\n\nPython ist ziemlich gut.\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\nfor i in range(3):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n15\n25\n40",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#formatierung",
    "href": "Python-Code.html#formatierung",
    "title": "2  Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren können direkt eingegeben werden. Text muss in einfache oder Doppelte Anführungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden soll, oder Erläuterungen.\n\n\n\nAusdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit dem Zeichen \\ über mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() können Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einrückung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengehörigen Code-Block. Die for-Schleife führt alle Anweisungen im eingerückten Ausführungsblock aus. Die folgende, nicht eingerückte Zeile markiert den Beginn einer neuen, nicht zur Schleife gehörigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#datentypen",
    "href": "Python-Code.html#datentypen",
    "title": "2  Python-Code",
    "section": "2.2 Datentypen",
    "text": "2.2 Datentypen\nPython ist eine objektorientierte Programmiersprache. Ein Objekt ist eine Einheit mit bestimmten Eigenschaften und Verhaltensweisen. Jedes Objekt gehört zu einer Klasse, die die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Die Klasse ist die Vorlage für jedes Objekt der Klasse. In Python werden Klassen (class) auch Typen (type) genannt (In den Anfängen von Python waren Klassen und Typen noch verschieden).\n\nprint(type(2), 2+2 )\nprint(type('a'), 'a'+'a')\nprint(type(True), True+True)\n\n&lt;class 'int'&gt; 4\n&lt;class 'str'&gt; aa\n&lt;class 'bool'&gt; 2\n\n\nPython kennt sehr viele Datentypen mit unterschiedlichen Eigenschaften und Verhaltensweisen. In diesem Abschnitt werden die für die Datenanalyse wichtigen Datentypen vorgestellt.\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von Максим Пе ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n \nDie print-Funktion haben Sie bereits kennengelernt. Quelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#klassen-typen-und-objekte",
    "href": "Python-Code.html#klassen-typen-und-objekte",
    "title": "2  Python-Code",
    "section": "2.2 Klassen, Typen und Objekte",
    "text": "2.2 Klassen, Typen und Objekte\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt gehört zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Objekte “erben” die Eigenschaften der Klasse, zu der sie gehören. In Python werden Klassen (class) auch Typen (type) genannt (In den Anfängen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abhängig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + für die Klassen Ganzzahlen (‘int’), Zeichenfolgen (‘str’) und Boolesche Werte (‘bool’) definiert ist. Anders verhält es sich mit None, also nicht existenten Werten:\n\ntry:\n  None + None\nexcept TypeError as error:\n  print(error)\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von Максим Пе ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n \nIn diesem Abschnitt werden die für die Datenanalyse wichtigsten Datentypen vorgestellt.\n\nZahlen\n…\n\n\nZahlen\nZu den Zahlen gehören Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardmäßig im Dezimalsystem eingegeben und können positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDarüber hinaus können Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Binärsystem arbeiten, können Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Binär ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen müssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Binärbruch, der 0.1 annähert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Binärapproximation repräsentiert werden. Python gibt zwar die jeweils kürzeste Dezimalzahl aus, da Berechnungen aber binär durchgeführt werden, kann sich bei Berechnungen die nächste Binärapproximation und damit die zugehörige kürzeste Dezimalzahl ändern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die kürzeste Dezimalzahl zur Binärapproximation\nprint(format(0.1, '.17g')) # Die nächstlängere Dezimalzahl zur selben Binärapproximation\nprint(0.3 - 0.2) # binär gerechnet, ändert sich die Binärapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungewöhnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\n\n\n\nArithmetische Operatoren\nMit arithmetischen Operatoren können die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, außer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grundsätzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollständige Übersicht der Reihenfolge der Ausführung ist in der Pythondokumentation aufgeführt. Für die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgeführt.\n\n\nAufgaben Zahlen\nLösen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\n𝟣 + 𝟤6 / 𝟧 = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist größer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent jährlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent jährlicher Rendite\n\n\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nMusterlösung Zahlen\n\n\n\n\n\n\n\n\n\n\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir später kennenlernen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\n\n\nLogische Operatoren\nZu den logischen Operatoren gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgeführt. Gleichrangige Operatoren werden von links nach rechts ausgeführt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / größer als / größer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis 2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Binärsystem). Zu beachten ist, dass die bitweisen Operatoren Ausführungspriorität vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren für die Datenanalyse nicht benötigt. Vermeiden Sie unnötige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch für Mengen (die wir später kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der Übergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].\n\n\n\n\n\n\n\n\nAufgaben boolsche Werte\nLösen Sie die Aufgaben mit Python.\n\nIst das Verhältnis aus 44 zu 4.5 größer als 10?\nIst es wahr, dass 4.5 größer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPrüfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n\n\nZeichenfolgen\nZeichenfolgen (englisch string) werden in Python in einfache oder doppelte Anführungszeichen gesetzt.\n\nprint('eine x-beliebige Zeichefolge')\nprint(\"noch eine x-beliebige Zeichenfolge\")\n\neine x-beliebige Zeichefolge\nnoch eine x-beliebige Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge können einfache oder doppelte Anführungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschließenden Anführungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Mit dem Steuerzeichen \\\\ funktionieren auch die gleichen \\\"Anführungszeichen\\\" wie die umschließenden.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nMit dem Steuerzeichen \\ funktionieren auch die gleichen \"Anführungszeichen\" wie die umschließenden.\nErst ein    Tabstopp, dann eine\nneue Zeile.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#logische-operationen",
    "href": "Python-Code.html#logische-operationen",
    "title": "2  Python-Code schreiben",
    "section": "2.4 Logische Operationen",
    "text": "2.4 Logische Operationen\nZu den logischen Operationen gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / größer als\n\n\n&lt;=, &gt;=\nkleiner / größer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nergänzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\nstring-formating mit f-strings\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#gleitkommazahlen",
    "href": "Python-Code.html#gleitkommazahlen",
    "title": "2  Python-Code schreiben",
    "section": "2.3 Gleitkommazahlen",
    "text": "2.3 Gleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Binärsystem arbeiten, können Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Binär ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen müssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Binärbruch von 0.1 ist in Dezimalschreibweise 3602879701896397 / 2^55). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Binärapproximation repräsentiert werden. Python gibt zwar die jeweils kürzeste Dezimalzahl aus, da Berechnungen aber binär durchgeführt werden, kann sich bei Berechnungen die nächste Binärapproximation und damit die zugehörige kürzeste Dezimalzahl ändern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die kürzeste Dezimalzahl zur Binärapproximation\nprint(format(0.1, '.17g')) # Die nächstlängere Dezimalzahl zur selben Binärapproximation\nprint(0.3 - 0.2) # binär gerechnet, ändert sich die Binärapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungewöhnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\nAbhilfe schafft in diesem Fall die Funktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()… ein paar Funktionen für die Ausgabe von strings ohne ’’ und ohne ,\n\nprint(format(0.1, ‘.17g’)) # 17 signifikante Stellen\nprint(format(0.1, ‘.17f’)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nOperationen mit Zahlen, dann Übungsaufgaben Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche größer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir später kennenlernen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann Übungsaufgaben Zwei Divisionen vergleichen, welche größer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#python-code-schreiben",
    "href": "Python-Code.html#python-code-schreiben",
    "title": "2  Python-Code schreiben",
    "section": "",
    "text": "Zahlen und Operatoren können direkt eingegeben werden. Text muss in einfache oder Doppelte Anführungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden soll, oder Erläuterungen.\n\n\n\nAusdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit dem Zeichen \\ über mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() können Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einrückung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengehörigen Code-Block. Die for-Schleife führt alle Anweisungen im eingerückten Ausführungsblock aus. Die folgende, nicht eingerückte Zeile markiert den Beginn einer neuen, nicht zur Schleife gehörigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#ausgabe-formatieren",
    "href": "Python-Code.html#ausgabe-formatieren",
    "title": "2  Python-Code",
    "section": "2.4 Ausgabe formatieren",
    "text": "2.4 Ausgabe formatieren\nFunktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()… ein paar Funktionen für die Ausgabe von strings ohne ’’ und ohne ,\n\nprint(format(0.1, ‘.17g’)) # 17 signifikante Stellen\nprint(format(0.1, ‘.17f’)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#arithmetische-operatoren",
    "href": "Python-Code.html#arithmetische-operatoren",
    "title": "2  Python-Code schreiben",
    "section": "2.3 Arithmetische Operatoren",
    "text": "2.3 Arithmetische Operatoren\nMit arithmetischen Operatoren können die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, außer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grundsätzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollständige Übersicht der Reihenfolge der Ausführung ist in der Pythondokumentation aufgeführt. Für die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgeführt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#aufgaben-rechenoperationen",
    "href": "Python-Code.html#aufgaben-rechenoperationen",
    "title": "2  Python-Code schreiben",
    "section": "2.4 Aufgaben Rechenoperationen",
    "text": "2.4 Aufgaben Rechenoperationen\nLösen Sie die folgenden Aufgaben 1. 4 + 2 * 4 = ? 2. 2 hoch 12? 3. Was ist der Rest aus 315 geteilt durch 4? 4. 𝟣+𝟤6/𝟧 Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche größer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir später kennenlernen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann Übungsaufgaben Zwei Divisionen vergleichen, welche größer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden\n\n\nLogische Operatoren\nZu den logischen Operatoren gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / größer als\n\n\n&lt;=, &gt;=\nkleiner / größer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nergänzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\n\n\nZeichenketten",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#variablen",
    "href": "Python-Code.html#variablen",
    "title": "2  Python-Code",
    "section": "2.3 Variablen",
    "text": "2.3 Variablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen müssen in Python nicht initialisiert werden. Der Typ der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nErklären, warum Sie bereits Variablen erstellt und verwendet haben… Python has no command for declaring a variable.\nA variable is created the moment you first assign a value to it.\nVariables do not need to be declared with any particular type, and can even change type after they have been set.\n\nBenennung von Variablen\nsprechende Variablen Die Benennung von Variablen ist (meist) dem jeweiligen Programmierer überlassen, es empfiehlt sich jedoch selbsterklärende Variablennamen zu vergeben. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\nUnter selbsterklärenden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden.\nZeigen, wie man den Typ einer Variable bestimmt und ändert. (type(x), int(), ord() … das ist im m-EsD)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#python-code",
    "href": "Python-Code.html#python-code",
    "title": "2  Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren können direkt eingegeben werden. Text muss in einfache oder Doppelte Anführungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden soll, oder Erläuterungen.\n\n\n\nAusdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit dem Zeichen \\ über mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() können Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einrückung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengehörigen Code-Block. Die for-Schleife führt alle Anweisungen im eingerückten Ausführungsblock aus. Die folgende, nicht eingerückte Zeile markiert den Beginn einer neuen, nicht zur Schleife gehörigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  }
]