[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Python",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nKeine Voraussetzungen, hilfreich ist der w-Pseudocode\nQuerverweis auf:\n\nw-NumPy\nw-Pandas",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Bausteine werden die Grundzüge der Programmierung mit Python vermittelt.\n\nGrundbegriffe der objektorientierten Programmierung\nPython-Code schreiben, Variablen erstellen, Operationen durchführen, Ausgabe formatieren\nFunktionen\nModule und Pakete laden\nDokumentation lesen und verwenden",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#einleitung",
    "href": "index.html#einleitung",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Einleitung",
    "text": "Einleitung\nEinleitungstext",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "einleitung.html",
    "href": "einleitung.html",
    "title": "1  Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "Die Erzeugung und Auswertung von Daten ist ein zentraler Bestandteil wissenschaftlicher Forschung. Die computergestützte Datenanalyse ermöglicht es, große Datenmengen (teil-)automatisiert auszuwerten. Gut lesbare Skriptsprachen wie Python sorgen für eine nachvollziehbare Datenverarbeitung und ermöglichen es, Analysen “auf Knopfdruck” zu wiederholen oder anzupassen.\n\n\n\n\nLogo der Programmiersprache Python\n\n\nPython Logo von Python Software Foundation steht unter der GPLv3. Die Wort-Bild-Marke ist markenrechtlich geschützt: https://www.python.org/psf/trademarks/. Das Werk ist abrufbar auf wikimedia. 2008\n\n \nAls Skriptsprache werden Python-Programme nicht in ein fertiges Programm übersetzt, sondern von einem sogenannten Interpreter, der die Programmanweisungen in Maschinencode für das jeweilige Computersystem übersetzt, ausgeführt. Dadurch kann das Skript auf verschiedenen Computersystemen ausgeführt werden. Zwar sind interpretierte Sprachen langsamer als fertig übersetzte Programme. Bei rechenintensiven Alogrithmen helfen jedoch spezialisierte Pakete, die Rechenleistung von Python deutlich zu steigern und diesen Unterschied fast ganz auszugleichen.\nPython kommt als schlichte Konsole daher. Zahlreiche Funktionen wie Codeformatierung, Codevervollständigung und Fehleranalyse werden durch eine sogenannte integrierte Entwicklungsumgebung (integrated development environment, IDE) bereitgestellt.\n\n\n\n\n\nProgrammentwicklung mit Python\n\n\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "Python-Code.html",
    "href": "Python-Code.html",
    "title": "2  Python-Code",
    "section": "",
    "text": "2.1 Python-Code\nBei der Formatierung von Python-Code müssen nur wenige Punkte beachtet werden.\nprint(1 + 2)\nprint('Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\nHallo Welt!\nHallo Python!\n# bloß nicht übertreiben\n# print(\"Python ist großartig!\") # das ist übertrieben\nprint(\"Python ist ziemlich gut.\") # das ist realistisch\n\nPython ist ziemlich gut.\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\nIn dem obenstehenden Beispiel werden Variablen angelegt. Mit Variablen beschäftigten wir uns später in diesem Abschnitt. Trotzdem möchte ich Sie bitten, sich variable1 und variable2 nocheinmal kurz anzusehen. Wir kommen später darauf zurück.\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\nfor i in range(3):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n15\n25\n40",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#formatierung",
    "href": "Python-Code.html#formatierung",
    "title": "2  Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren können direkt eingegeben werden. Text muss in einfache oder Doppelte Anführungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden soll, oder Erläuterungen.\n\n\n\nAusdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit dem Zeichen \\ über mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() können Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einrückung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengehörigen Code-Block. Die for-Schleife führt alle Anweisungen im eingerückten Ausführungsblock aus. Die folgende, nicht eingerückte Zeile markiert den Beginn einer neuen, nicht zur Schleife gehörigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#datentypen",
    "href": "Python-Code.html#datentypen",
    "title": "2  Python-Code",
    "section": "2.2 Datentypen",
    "text": "2.2 Datentypen\nPython ist eine objektorientierte Programmiersprache. Ein Objekt ist eine Einheit mit bestimmten Eigenschaften und Verhaltensweisen. Jedes Objekt gehört zu einer Klasse, die die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Die Klasse ist die Vorlage für jedes Objekt der Klasse. In Python werden Klassen (class) auch Typen (type) genannt (In den Anfängen von Python waren Klassen und Typen noch verschieden).\n\nprint(type(2), 2+2 )\nprint(type('a'), 'a'+'a')\nprint(type(True), True+True)\n\n&lt;class 'int'&gt; 4\n&lt;class 'str'&gt; aa\n&lt;class 'bool'&gt; 2\n\n\nPython kennt sehr viele Datentypen mit unterschiedlichen Eigenschaften und Verhaltensweisen. In diesem Abschnitt werden die für die Datenanalyse wichtigen Datentypen vorgestellt.\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von Максим Пе ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n \nDie print-Funktion haben Sie bereits kennengelernt. Quelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#klassen-typen-und-objekte",
    "href": "Python-Code.html#klassen-typen-und-objekte",
    "title": "2  Python-Code",
    "section": "2.2 Klassen, Typen und Objekte",
    "text": "2.2 Klassen, Typen und Objekte\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt gehört zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Objekte “erben” die Eigenschaften der Klasse, zu der sie gehören. In Python werden Klassen (class) auch Typen (type) genannt (In den Anfängen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abhängig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + für die Klassen Ganzzahlen (‘int’), Zeichenfolgen (‘str’) und Boolesche Werte (‘bool’) definiert ist. Anders verhält es sich mit None, also nicht existenten Werten:\n\ntry:\n  None + None\nexcept TypeError as error:\n  print(error)\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von Максим Пе ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n \nIn diesem Abschnitt werden die für die Datenanalyse wichtigsten Datentypen vorgestellt.\n\nZahlen\nZu den Zahlen gehören Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardmäßig im Dezimalsystem eingegeben und können positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDarüber hinaus können Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Binärsystem arbeiten, können Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Binär ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen müssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Binärbruch, der 0.1 annähert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Binärapproximation repräsentiert werden. Python gibt zwar die jeweils kürzeste Dezimalzahl aus, da Berechnungen aber binär durchgeführt werden, kann sich bei Berechnungen die nächste Binärapproximation und damit die zugehörige kürzeste Dezimalzahl ändern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die kürzeste Dezimalzahl zur Binärapproximation\nprint(format(0.1, '.17g')) # Die nächstlängere Dezimalzahl zur selben Binärapproximation\nprint(0.3 - 0.2) # binär gerechnet, ändert sich die Binärapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungewöhnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\n\n\n\nArithmetische Operatoren\nMit arithmetischen Operatoren können die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, außer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grundsätzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollständige Übersicht der Reihenfolge der Ausführung ist in der Pythondokumentation aufgeführt. Für die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgeführt.\n\n\nAufgaben Zahlen\nLösen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\n𝟣 + 𝟤6 / 𝟧 = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist größer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent jährlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent jährlicher Rendite\n\n\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nMusterlösung Zahlen\n\n\n\n\n\n\n\n\n\n\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an und gehören in Python deshalb zu den Zahlen.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir später kennenlernen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\n\n\nLogische Operatoren\nZu den logischen Operatoren gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgeführt. Gleichrangige Operatoren werden von links nach rechts ausgeführt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / größer als / größer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis 2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Binärsystem). Zu beachten ist, dass die bitweisen Operatoren Ausführungspriorität vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren für die Datenanalyse nicht benötigt. Vermeiden Sie unnötige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch für Mengen (die wir später kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der Übergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].\n\n\n\n\n\n\n\n\nAufgaben boolsche Werte\nLösen Sie die Aufgaben mit Python.\n\nIst das Verhältnis aus 44 zu 4.5 größer als 10?\nIst es wahr, dass 4.5 größer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPrüfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n\n\nZeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anführungszeichen gesetzt.\n\nprint('eine x-beliebige Zeichefolge')\nprint(\"noch eine x-beliebige Zeichenfolge\")\n\neine x-beliebige Zeichefolge\nnoch eine x-beliebige Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge können einfache oder doppelte Anführungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschließenden Anführungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Mit dem Steuerzeichen \\\\ funktionieren auch die gleichen \\\"Anführungszeichen\\\" wie die umschließenden.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nMit dem Steuerzeichen \\ funktionieren auch die gleichen \"Anführungszeichen\" wie die umschließenden.\nErst ein    Tabstopp, dann eine\nneue Zeile.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#logische-operationen",
    "href": "Python-Code.html#logische-operationen",
    "title": "2  Python-Code schreiben",
    "section": "2.4 Logische Operationen",
    "text": "2.4 Logische Operationen\nZu den logischen Operationen gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / größer als\n\n\n&lt;=, &gt;=\nkleiner / größer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nergänzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\nstring-formating mit f-strings\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#gleitkommazahlen",
    "href": "Python-Code.html#gleitkommazahlen",
    "title": "2  Python-Code schreiben",
    "section": "2.3 Gleitkommazahlen",
    "text": "2.3 Gleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Binärsystem arbeiten, können Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Binär ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen müssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Binärbruch von 0.1 ist in Dezimalschreibweise 3602879701896397 / 2^55). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Binärapproximation repräsentiert werden. Python gibt zwar die jeweils kürzeste Dezimalzahl aus, da Berechnungen aber binär durchgeführt werden, kann sich bei Berechnungen die nächste Binärapproximation und damit die zugehörige kürzeste Dezimalzahl ändern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die kürzeste Dezimalzahl zur Binärapproximation\nprint(format(0.1, '.17g')) # Die nächstlängere Dezimalzahl zur selben Binärapproximation\nprint(0.3 - 0.2) # binär gerechnet, ändert sich die Binärapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungewöhnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\nAbhilfe schafft in diesem Fall die Funktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()… ein paar Funktionen für die Ausgabe von strings ohne ’’ und ohne ,\n\nprint(format(0.1, ‘.17g’)) # 17 signifikante Stellen\nprint(format(0.1, ‘.17f’)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nOperationen mit Zahlen, dann Übungsaufgaben Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche größer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir später kennenlernen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann Übungsaufgaben Zwei Divisionen vergleichen, welche größer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#python-code-schreiben",
    "href": "Python-Code.html#python-code-schreiben",
    "title": "2  Python-Code schreiben",
    "section": "",
    "text": "Zahlen und Operatoren können direkt eingegeben werden. Text muss in einfache oder Doppelte Anführungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden soll, oder Erläuterungen.\n\n\n\nAusdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit dem Zeichen \\ über mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() können Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einrückung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengehörigen Code-Block. Die for-Schleife führt alle Anweisungen im eingerückten Ausführungsblock aus. Die folgende, nicht eingerückte Zeile markiert den Beginn einer neuen, nicht zur Schleife gehörigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#ausgabe-formatieren",
    "href": "Python-Code.html#ausgabe-formatieren",
    "title": "2  Python-Code",
    "section": "2.3 Ausgabe formatieren",
    "text": "2.3 Ausgabe formatieren\nMit sogenannten f-Strings können formatierte Zeichenketten erstellt werden. Formatierte Zeichenketten werden mit einem vorgesetzten f vor den Anführungsstrichen erstellt. Werte und Variablen können durch Platzhalter eingesetzt werden, die mit geschweiften Klammern {} angegeben und mit Formattierungsinformationen versehen werden. Das Formatierungsformat innerhalb der geschweiften Klammer ist, vereinfacht dargestellt:\n{Variablenname:PlatzbedarfAusgabetyp}\nEin f-String mit Platzhaltern ohne Formatierungsinformationen:\n\nzahl1 = 5\nzahl2 = 7\nverhältnis = zahl1 / zahl2\nprint(f\"Das Verhältnis von {zahl1} zu {zahl2} ist {verhältnis}.\")\n\nDas Verhältnis von 5 zu 7 ist 0.7142857142857143.\n\n\nDie Anzahl der darzustellenden Nachkommastellen kann wie folgt festgelegt werden: {verhältnis:.2f}.\n\n: leitet die Formatierungsbefehle ein.\n. gibt an, dass Formatierungsinformationen für die Darstellung hinter dem Dezimaltrennzeichen folgen.\n2 ist der Wert für die darzustellenden Nachkommastellen.\nf spezifiziert die Darstellung einer Gleitkommazahl ‘float’.\n\n\nprint(f\"Das Verhältnis von {zahl1} zu {zahl2} ist {verhältnis:.2f}.\")\n\nDas Verhältnis von 5 zu 7 ist 0.71.\n\n\nDas gleiche ist mit einem Wert möglich:\n\nprint(f\"Das Verhältnis ist genauer {0.7142857142857143:.3f}.\")\n\nDas Verhältnis ist genauer 0.714.\n\n\nEin Wert für die insgesamt darzustellenden Stellen wird vor dem Dezimaltrennzeichen übergeben {verhältnis:7.2f} bzw. inklusive führender Nullen {verhältnis:07.2f}:\n\nprint(f\"Das Verhältnis von {zahl1} zu {zahl2} ist {verhältnis:7.2f}.\")\nprint(f\"Das Verhältnis ist genauer {0.7142857142857143:07.3f}.\")\n\nDas Verhältnis von 5 zu 7 ist    0.71.\nDas Verhältnis ist genauer 000.714.\n\n\nDas Dezimaltrennzeichen zählt als eine Stelle.\nHäufig verwendete Formatierung sind:\n\nganze ZahlenGleitkommazahlenZeichenketten\n\n\nGanze Zahlen haben den Ausgabetyp d.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nnd\nn-Stellen werden für die Ausgabe verwendet\n\n\n0nd\nAusgabe von n-Stellen, wobei die Leerstellen mit Nullen aufgefüllt werden.\n\n\n+d\nAusgabe des Vorzeichens auch bei positiven Zahlen\n\n\n\n\n\nGleitkommazahlen haben die Ausgabetypen f und e.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\n.mf\nm-Stellen werden für die Nachkommastellen genutzt.\n\n\nn.mf\nInsgesamt werden n-Stellen verwendet, wobei m-Stellen für die Nachkommastellen genutzt werden.\n\n\nn.me\nGenauso, aber die Ausgabe erfolgt in exponentieller Schreibweise.\n\n\n\n\n\nZeichenketten haben den Ausgabetyp s.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nns\nInsgesamt werden n-Stellen verwendet.\n\n\n&lt;ns, &gt;ns, ^ns\nGenauso, jedoch wird die Zeichenkette linksbündig, rechtsbündig bzw. zentriert platziert.\n\n\n\n\n\n\n(Arnold 2023b)\n**Funktionen wie round(), format() und string-Methoden wie .upper .lower ins nächste Kapitel schieben… sie sind eine gute Einleitung für die objektorientierte Programmierung (manche funktionieren nur mit Zahlen, andere nur mit Zeichen).\nZahlen: Funktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()… ein paar Funktionen für die Ausgabe von strings ohne ’’ und ohne ,\n\nprint(format(0.1, ‘.17g’)) # 17 signifikante Stellen\nprint(format(0.1, ‘.17f’)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nWie kann man die Exponentialschreibeweise ein- / ausschalten?\nMit f-strings{} können Werte und Variablen in eine Zeichenfolge eingesetzt werden.\n\nprint(\"Ich muss einkaufen gehen.\")\nprint(f\"Ich muss {'Äpfel'} einkaufen gehen.\")\n\neinkauf = 'Äpfel'\nprint(f\"Ich muss {einkauf} einkaufen gehen.\")\n\nIch muss einkaufen gehen.\nIch muss Äpfel einkaufen gehen.\nIch muss Äpfel einkaufen gehen.\n\n\nStrings: Methoden .lower(), .upper(), .title() https://www.w3schools.com/python/python_ref_string.asp\nAls nächstes Kapitel: Sammeltypen (Liste, Tupel, Dict) Hinweis: Strings sind in Python eine Sequenz von Zeichen (Zeichenfolge), die unveränderlich ist (immutable). Bei der Arbeit mit strings fällt das nicht unbedingt auf. Beispiel ergänzen, bei dem ein string verändert wird. Tatsächlich wird aber immer ein neuer string angelegt.\nUm auf Elemente einer Zeichenfolge zuzugreifen, wird der Slicing-Operator [] verwendet. Als nächstes Kapitel: Funktionen if, while, for …, eigene Funktionen schreiben\n\n\n\n\nArnold, Simone. 2023a. „Datenanalyse mit Python. Datentypen und Grundlagen.“ Fachhochschule Dortmund.\n\n\n———. 2023b. „Datenanalyse mit Python. Funktionen Module Dateien.“ Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#arithmetische-operatoren",
    "href": "Python-Code.html#arithmetische-operatoren",
    "title": "2  Python-Code schreiben",
    "section": "2.3 Arithmetische Operatoren",
    "text": "2.3 Arithmetische Operatoren\nMit arithmetischen Operatoren können die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, außer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grundsätzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollständige Übersicht der Reihenfolge der Ausführung ist in der Pythondokumentation aufgeführt. Für die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgeführt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#aufgaben-rechenoperationen",
    "href": "Python-Code.html#aufgaben-rechenoperationen",
    "title": "2  Python-Code schreiben",
    "section": "2.4 Aufgaben Rechenoperationen",
    "text": "2.4 Aufgaben Rechenoperationen\nLösen Sie die folgenden Aufgaben 1. 4 + 2 * 4 = ? 2. 2 hoch 12? 3. Was ist der Rest aus 315 geteilt durch 4? 4. 𝟣+𝟤6/𝟧 Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche größer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir später kennenlernen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann Übungsaufgaben Zwei Divisionen vergleichen, welche größer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden\n\n\nLogische Operatoren\nZu den logischen Operatoren gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / größer als\n\n\n&lt;=, &gt;=\nkleiner / größer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nergänzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\n\n\nZeichenketten",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#variablen",
    "href": "Python-Code.html#variablen",
    "title": "2  Python-Code",
    "section": "2.3 Variablen",
    "text": "2.3 Variablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen müssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable ändert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable ändern, um das Ergebnis einer Operation aufnehmen zu können. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‘float’ zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enthält Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Fließkommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Fließkommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder übersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind für jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag für Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abträglich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nFür die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausführlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben lässt. Denn Programmcode wird deutlich häufiger gelesen als geschrieben. Können Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern können.\nFalls Sie sich nicht erinnern können, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Auflösung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAuflösung\n\n\n\n\n\n\nprint(type(var_3), type(variable1), type(a))\n\n&lt;class 'bool'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich “sprechende”, das heißt selbsterklärende, Variablennamen zu vergeben. Unter selbsterklärenden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einfließen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchlüsselwörter und Funktionsnamen\n\n\n\nIn Python reservierte Schlüsselwörter und Funktionsnamen sind ungeeignete Variablennamen. Während Python die Wertzuweisung zu Schlüsselwörtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen problemslos neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese natürlich nicht mehr. In diesem Fall müssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\n\n\n\nAufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit 𝗍 in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung für folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen für \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, überlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte können sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable für den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschließlich Einheiten) ein.\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nTipp 2.1: Musterlösung Aufgaben Variablen",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#python-code",
    "href": "Python-Code.html#python-code",
    "title": "2  Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren können direkt eingegeben werden. Text muss in einfache oder doppelte Anführungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden soll, oder Erläuterungen.\n\n\n\nAusdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit dem Zeichen \\ über mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() können Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einrückung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengehörigen Code-Block. Die for-Schleife führt alle Anweisungen im eingerückten Ausführungsblock aus. Die folgende, nicht eingerückte Zeile markiert den Beginn einer neuen, nicht zur Schleife gehörigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#klassen-typen-objekte-und-datentypen",
    "href": "Python-Code.html#klassen-typen-objekte-und-datentypen",
    "title": "2  Python-Code",
    "section": "2.2 Klassen, Typen, Objekte und Datentypen",
    "text": "2.2 Klassen, Typen, Objekte und Datentypen\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt gehört zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt, etwa welche Daten gespeichert und welche Funktionen ausgeführt werden können. Objekte “erben” die Eigenschaften der Klasse, zu der sie gehören. In Python werden Klassen (class) auch Typen (type) genannt (In den Anfängen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abhängig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + für die Klassen Ganzzahlen (‘int’), Zeichenfolgen (‘str’) und Boolesche Werte (‘bool’) definiert ist. Anders verhält es sich mit None, also nicht existenten Werten:\n\ntry:\n  None + None\nexcept TypeError as error:\n  print(error)\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von Максим Пе ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n \n\nDatentypen\nObjekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt an, wie die gespeicherten Werte von Python interpretiert werden sollen. Beispielsweise kann der Wert “1” ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar oder die Ausprägung einer kategorialen Variablen repräsentieren.\nIn der Pythonbasis gibt es nur einfache Datentypen wie Ganzzahl oder Gleitkommazahlen, weshalb der Unterschied zwischen Klassen und Datentypen nicht sofort offensichtlich ist. In Python sind die Begriffe manchmal synonym, etwa für die Klasse der Ganzzahlen ‘int’ und den Datentyp ‘int’. Jedes Objekt gehört zu einer Klasse, aber nicht jeder Klasse ist ein Datentyp zuordenbar - beispielsweise sind auch Funktionen Objekte und gehören einer eigenen Klasse an. Die Funktion print speichert aber keine Daten und hat deshalb auch keinen Datentyp.\n\ntype(print)\n\nbuiltin_function_or_method\n\n\nDeutlicher wird der Unterschied zwischen Klassen und Datentyp erst in spezialisierten Paketen wie NumPy Querverweis auf w-NumPy oder Pandas Querverweis auf w-Pandas, die weitere Datentypen in Python einführen, wie zum Beispiel Gleitkommazahlen mit 32 Bit (Datentyp ‘float32’) und 64 Bit Speicherplatzbedarf (Datentyp ‘float64’). Objekte vom Datentyp float32 und float64 gehören zur selben Klasse (siehe Beispiel): Sie haben die selben allgemeinen Eigenschaften und Verhaltensweisen. Sie haben aber einen unterschiedlichen Wertebereich und Speicherplatzbedarf - Gleitkommazahlen mit 64 Bit können größere Zahlen speichern, nehmen aber doppelt so viel Platz im Speicher des Computers ein.\n\n\n\n\n\n\nBeispiel 2.1: Datentypen in NumPy und Pandas\n\n\n\n\n\nDie Module NumPy und Pandas sind wichtige Bausteine für die Datenanalyse mit Python.\n\nimport numpy as np\n\nfloat_64 = np.array([1.0])\nprint(\"Der Datentyp des Objekts float_64 ist:\", float_64.dtype)\nprint(\"Das Objekt gehört zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_64), \"\\n\")\n\nfloat_32 = np.array([1.0], dtype = 'float32')\nprint(\"Der Datentyp des Objekts float_32 ist:\", float_32.dtype)\nprint(\"Das Objekt gehört zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_32))\n\nDer Datentyp des Objekts float_64 ist: float64\nDas Objekt gehört zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt; \n\nDer Datentyp des Objekts float_32 ist: float32\nDas Objekt gehört zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\nIn diesem Abschnitt werden die für die Datenanalyse wichtigsten Datentypen vorgestellt.\n\n\nZahlen\nZu den Zahlen gehören Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardmäßig im Dezimalsystem eingegeben und können positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDarüber hinaus können Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\")\nprint(1e-3, \"oder\", 1e+3)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\n0.001 oder 1000.0\n\n\nDa Computer im Binärsystem arbeiten, können Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Binär ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen müssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Binärbruch, der 0.1 annähert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Binärapproximation repräsentiert werden. Python gibt zwar die jeweils kürzeste Dezimalzahl aus, da Berechnungen aber binär durchgeführt werden, kann sich bei Berechnungen die nächste Binärapproximation und damit die zugehörige kürzeste Dezimalzahl ändern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die kürzeste Dezimalzahl zur Binärapproximation\nprint(format(0.1, '.17g')) # Die nächstlängere Dezimalzahl zur selben Binärapproximation\nprint(0.3 - 0.2) # binär gerechnet, ändert sich die Binärapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungewöhnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\n\n\n\nArithmetische Operatoren\nMit arithmetischen Operatoren können die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, außer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grundsätzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollständige Übersicht der Reihenfolge der Ausführung ist in der Pythondokumentation aufgeführt. Für die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgeführt.\n\n\nAufgaben Zahlen\nLösen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\n𝟣 + 𝟤6 / 𝟧 = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist größer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent jährlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent jährlicher Rendite\n\n\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nMusterlösung Zahlen\n\n\n\n\n\n\n\n\n\n\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an und gehören in Python deshalb zu den Zahlen.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir später kennenlernen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\n\n\nLogische Operatoren\nZu den logischen Operatoren gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgeführt. Gleichrangige Operatoren werden von links nach rechts ausgeführt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / größer als / größer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis 2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Binärsystem). Zu beachten ist, dass die bitweisen Operatoren Ausführungspriorität vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint(5 & 10)\nprint(10 &gt; False &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\n0\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren für die Datenanalyse nicht benötigt. Vermeiden Sie unnötige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch für Mengen (die wir später kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der Übergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].\n\n\n\n\n\n\n\n\nAufgaben boolsche Werte\nLösen Sie die Aufgaben mit Python.\n\nIst das Verhältnis aus 44 zu 4.5 größer als 10?\nIst es wahr, dass 4.5 größer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPrüfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n\n\nZeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anführungszeichen gesetzt.\n\nprint('eine x-beliebige Zeichenfolge')\nprint(\"noch eine x-beliebige Zeichenfolge\")\n\neine x-beliebige Zeichenfolge\nnoch eine x-beliebige Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge können einfache oder doppelte Anführungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschließenden Anführungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Das Steuerzeichen \\\\ ermöglicht die gleichen \\\"Anführungszeichen\\\" in der Ausgabe von print.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nDas Steuerzeichen \\ ermöglicht die gleichen \"Anführungszeichen\" in der Ausgabe von print.\nErst ein    Tabstopp, dann eine\nneue Zeile.\n\n\nEin vorangestelltes r bewirkt, dass das Steuerzeichen \\ nicht verarbeitet wird (raw string literal). Dies ist beispielsweise bei der Arbeit mit Dateipfaden praktisch.\n\nprint(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\nprint(r\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\nDie Daten liegen unter: C:  olle_daten\nordpol\\weihnachtsmann\nDie Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\n\n\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\w'\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\w'\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_26864\\2438942157.py:1: SyntaxWarning: invalid escape sequence '\\w'\n  print(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\n\n\n\nOperationen mit Zeichenfolgen\nEinige Operatoren funktionieren auch mit Daten vom Typ string.\n\n# string + string\nprint('a' + 'b') # -, *, / funktionieren nicht\nprint(\"\\n\")\n\n# string + Zahl\nprint(15 * 'a') # +, -, / funktionieren nicht\nprint(\"\\n\")\n\n# logische Operatoren\nprint('a' &lt; 'b', 'a' &gt;= 'b', 'a' != 'b')\nprint('a' or 'b', 'a' and 'b')\n\nab\n\n\naaaaaaaaaaaaaaa\n\n\nTrue False True\na b\n\n\n\n\nAufgaben Zeichenfolgen\nLösen Sie die Aufgaben mit Python.\n\nWas passiert, wenn Sie die Zeichenfolge “Python” mit “for beginners” addieren?\nErzeugen Sie eine Zeichenfolge, die 10 mal die Zeichenfolge “tick tack”.\nWelche Zeichenfolge ist kleiner, “Aachen” oder “Bern”. Warum ist das so, wie werden Zeichenfolgen verglichen?\nGeben Sie den Dateipfad aus: “~_daten”\n\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nTipp 2.1: Musterlösung Aufgaben Zeichenfolgen\n\n\n\n\n\n\n\n\n\n\n\nVariablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen müssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable ändert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable ändern, um das Ergebnis einer Operation aufnehmen zu können. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‘float’ zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enthält Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Fließkommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Fließkommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder übersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind für jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag für Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abträglich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nFür die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausführlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben lässt. Denn Programmcode wird deutlich häufiger gelesen als geschrieben. Können Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern können.\nFalls Sie sich nicht erinnern können, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Auflösung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAuflösung\n\n\n\n\n\n\nprint(type(var_3), type(variable1), type(a))\n\n&lt;class 'bool'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich “sprechende”, das heißt selbsterklärende, Variablennamen zu vergeben. Unter selbsterklärenden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einfließen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchlüsselwörter und Funktionsnamen\n\n\n\nIn Python reservierte Schlüsselwörter und Funktionsnamen sind ungeeignete Variablennamen. Während Python die Wertzuweisung zu Schlüsselwörtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen problemslos neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese natürlich nicht mehr. In diesem Fall müssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\n\n\n\n\nAufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit 𝗍 in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung für folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen für \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, überlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte können sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable für den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschließlich Einheiten) ein.\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nTipp 2.2: Musterlösung Aufgaben Variablen\n\n\n\n\n\n\n\n\n\n(Arnold 2023a)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#aufgaben-zeichenfolgen",
    "href": "Python-Code.html#aufgaben-zeichenfolgen",
    "title": "2  Python-Code",
    "section": "2.3 Aufgaben Zeichenfolgen",
    "text": "2.3 Aufgaben Zeichenfolgen\n\nVariablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen müssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable ändert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable ändern, um das Ergebnis einer Operation aufnehmen zu können. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‘float’ zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enthält Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Fließkommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Fließkommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder übersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind für jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag für Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abträglich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nFür die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausführlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben lässt. Denn Programmcode wird deutlich häufiger gelesen als geschrieben. Können Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern können.\nFalls Sie sich nicht erinnern können, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Auflösung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAuflösung\n\n\n\n\n\n\nprint(type(var_3), type(variable1), type(a))\n\n&lt;class 'bool'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich “sprechende”, das heißt selbsterklärende, Variablennamen zu vergeben. Unter selbsterklärenden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einfließen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchlüsselwörter und Funktionsnamen\n\n\n\nIn Python reservierte Schlüsselwörter und Funktionsnamen sind ungeeignete Variablennamen. Während Python die Wertzuweisung zu Schlüsselwörtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen problemslos neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese natürlich nicht mehr. In diesem Fall müssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\n\n\n\n\nAufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit 𝗍 in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung für folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen für \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, überlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte können sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable für den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschließlich Einheiten) ein.\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nTipp 2.1: Musterlösung Aufgaben Variablen",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "python-code.html",
    "href": "python-code.html",
    "title": "2  Python-Code",
    "section": "",
    "text": "2.1 Python-Code\nBei der Formatierung von Python-Code müssen nur wenige Punkte beachtet werden.\nprint(1 + 2)\nprint('Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\nHallo Welt!\nHallo Python!\n# Ein reiner Kommentar\n# print(\"Python ist großartig!\") # auskommentierter Code, gefolgt von einem Kommentar\nprint(\"Python ist ziemlich gut.\") # auszuführender Code, gefolgt von einem Kommentar\n\nPython ist ziemlich gut.\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\nIn dem obenstehenden Beispiel werden Variablen angelegt. Mit Variablen beschäftigten wir uns später in diesem Abschnitt. Trotzdem möchte ich Sie bitten, sich variable1 und variable2 nocheinmal kurz anzusehen. Wir kommen später darauf zurück.\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\nfor i in range(3):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n15\n25\n40",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "python-code.html#python-code",
    "href": "python-code.html#python-code",
    "title": "2  Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren können direkt eingegeben werden. Text muss in einfache oder doppelte Anführungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden soll, oder Erläuterungen.\n\n\n\nAusdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit dem Zeichen \\ über mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() können Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einrückung mit Leerzeichen kennzeichnet einen zusammengehörigen Code-Block. Innerhalb eines Code-Blocks muss immer die gleiche Anzahl Leerzeichen verwendet werden. Es muss mindestens ein Leerzeichen gesetzt werden, ansonsten ist die Anzahl der Leerzeichen beliebig. Üblich sind 2 oder 4 Leerzeichen. Die for-Schleife führt alle Anweisungen im eingerückten Ausführungsblock aus. Die folgende, nicht eingerückte Zeile markiert den Beginn einer neuen, nicht zur Schleife gehörigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "python-code.html#klassen-typen-objekte-und-datentypen",
    "href": "python-code.html#klassen-typen-objekte-und-datentypen",
    "title": "2  Python-Code",
    "section": "2.2 Klassen, Typen, Objekte und Datentypen",
    "text": "2.2 Klassen, Typen, Objekte und Datentypen\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt gehört zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt, etwa welche Daten gespeichert und welche Funktionen ausgeführt werden können. Objekte “erben” die Eigenschaften der Klasse, zu der sie gehören. In Python werden Klassen (class) auch Typen (type) genannt (In den Anfängen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abhängig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + für die Klassen Ganzzahlen (‘int’), Zeichenfolgen (‘str’) und Boolesche Werte (‘bool’) definiert ist. Anders verhält es sich mit None, also nicht existenten Werten:\n\ntry:\n  None + None\nexcept TypeError as error:\n  print(error)\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von Максим Пе ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n \n\nDatentypen\nObjekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt an, wie die gespeicherten Werte von Python interpretiert werden sollen. Beispielsweise kann der Wert “1” ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar oder die Ausprägung einer kategorialen Variablen repräsentieren.\nIn der Pythonbasis gibt es nur einfache Datentypen wie Ganzzahl oder Gleitkommazahlen, weshalb der Unterschied zwischen Klassen und Datentypen nicht sofort offensichtlich ist. In Python sind die Begriffe manchmal synonym, etwa für die Klasse der Ganzzahlen ‘int’ und den Datentyp ‘int’. Jedes Objekt gehört zu einer Klasse, aber nicht jeder Klasse ist ein Datentyp zuordenbar - beispielsweise sind auch Funktionen Objekte und gehören einer eigenen Klasse an. Die Funktion print speichert aber keine Daten und hat deshalb auch keinen Datentyp.\n\ntype(print)\n\nbuiltin_function_or_method\n\n\nDeutlicher wird der Unterschied zwischen Klassen und Datentyp erst in spezialisierten Paketen wie NumPy Querverweis auf w-NumPy oder Pandas Querverweis auf w-Pandas, die weitere Datentypen in Python einführen, wie zum Beispiel Gleitkommazahlen mit 32 Bit (Datentyp ‘float32’) und 64 Bit Speicherplatzbedarf (Datentyp ‘float64’). Objekte vom Datentyp float32 und float64 gehören zur selben Klasse (siehe Beispiel): Sie haben die selben allgemeinen Eigenschaften und Verhaltensweisen. Sie haben aber einen unterschiedlichen Wertebereich und Speicherplatzbedarf - Gleitkommazahlen mit 64 Bit können größere Zahlen speichern, nehmen aber doppelt so viel Platz im Speicher des Computers ein.\n\n\n\n\n\n\nBeispiel 2.1: Datentypen in NumPy und Pandas\n\n\n\n\n\nDie Module NumPy und Pandas sind wichtige Bausteine für die Datenanalyse mit Python.\n\nimport numpy as np\n\nfloat_64 = np.array([1.0])\nprint(\"Der Datentyp des Objekts float_64 ist:\", float_64.dtype)\nprint(\"Das Objekt gehört zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_64), \"\\n\")\n\nfloat_32 = np.array([1.0], dtype = 'float32')\nprint(\"Der Datentyp des Objekts float_32 ist:\", float_32.dtype)\nprint(\"Das Objekt gehört zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_32))\n\nDer Datentyp des Objekts float_64 ist: float64\nDas Objekt gehört zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt; \n\nDer Datentyp des Objekts float_32 ist: float32\nDas Objekt gehört zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\nIn diesem Abschnitt werden die für die Datenanalyse wichtigsten Datentypen vorgestellt.\n\n\nZahlen\nZu den Zahlen gehören Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardmäßig im Dezimalsystem eingegeben und können positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDarüber hinaus können Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\")\nprint(1e-3, \"oder\", 1e+3)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\n0.001 oder 1000.0\n\n\nDa Computer im Binärsystem arbeiten, können Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Binär ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen müssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Binärbruch, der 0.1 annähert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Binärapproximation repräsentiert werden. Python gibt zwar die jeweils kürzeste Dezimalzahl aus, da Berechnungen aber binär durchgeführt werden, kann sich bei Berechnungen die nächste Binärapproximation und damit die zugehörige kürzeste Dezimalzahl ändern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die kürzeste Dezimalzahl zur Binärapproximation\nprint(format(0.1, '.17g')) # Die nächstlängere Dezimalzahl zur selben Binärapproximation\nprint(0.3 - 0.2) # binär gerechnet, ändert sich die Binärapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungewöhnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\n\n\n\nArithmetische Operatoren\nMit arithmetischen Operatoren können die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, außer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grundsätzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollständige Übersicht der Reihenfolge der Ausführung ist in der Pythondokumentation aufgeführt. Für die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgeführt.\n\n\nAufgaben Zahlen\nLösen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\n𝟣 + 𝟤6 / 𝟧 = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist größer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent jährlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent jährlicher Rendite\n\n\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nTipp 2.1: Musterlösung Zahlen\n\n\n\n\n\n\n\n\n\n\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an und gehören in Python deshalb zu den Zahlen.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary lernen wir in den folgenden Kapiteln kennen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\n\n\nLogische Operatoren\nZu den logischen Operatoren gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgeführt. Gleichrangige Operatoren werden von links nach rechts ausgeführt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / größer als / größer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis 2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Binärsystem). Zu beachten ist, dass die bitweisen Operatoren Ausführungspriorität vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint(5 & 10)\nprint(10 &gt; False &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\n0\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren für die Datenanalyse nicht benötigt. Vermeiden Sie unnötige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch für Mengen (die wir später kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der Übergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].\n\n\n\n\n\n\n\n\nAufgaben boolsche Werte\nLösen Sie die Aufgaben mit Python.\n\nIst das Verhältnis aus 44 zu 4.5 größer als 10?\nIst es wahr, dass 4.5 größer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPrüfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n\n\nZeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anführungszeichen gesetzt.\n\nprint('eine x-beliebige Zeichenfolge')\nprint(\"noch eine x-beliebige Zeichenfolge\")\n\neine x-beliebige Zeichenfolge\nnoch eine x-beliebige Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge können einfache oder doppelte Anführungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschließenden Anführungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Das Steuerzeichen \\\\ ermöglicht die gleichen \\\"Anführungszeichen\\\" in der Ausgabe von print.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nDas Steuerzeichen \\ ermöglicht die gleichen \"Anführungszeichen\" in der Ausgabe von print.\nErst ein    Tabstopp, dann eine\nneue Zeile.\n\n\nEin vorangestelltes r bewirkt, dass das Steuerzeichen \\ nicht verarbeitet wird (raw string literal). Dies ist beispielsweise bei der Arbeit mit Dateipfaden praktisch.\n\nprint(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\nprint(r\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\nDie Daten liegen unter: C:  olle_daten\nordpol\\weihnachtsmann\nDie Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\n\n\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\w'\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\w'\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_15736\\2438942157.py:1: SyntaxWarning: invalid escape sequence '\\w'\n  print(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\n\n\n\nOperationen mit Zeichenfolgen\nEinige Operatoren funktionieren auch mit Daten vom Typ string.\n\n# string + string\nprint('a' + 'b') # -, *, / funktionieren nicht\nprint(\"\\n\")\n\n# string + Zahl\nprint(15 * 'a') # +, -, / funktionieren nicht\nprint(\"\\n\")\n\n# logische Operatoren\nprint('a' &lt; 'b', 'a' &gt;= 'b', 'a' != 'b')\nprint('a' or 'b', 'a' and 'b')\n\nab\n\n\naaaaaaaaaaaaaaa\n\n\nTrue False True\na b\n\n\n\n\nAufgaben Zeichenfolgen\nLösen Sie die Aufgaben mit Python.\n\nWas passiert, wenn Sie die Zeichenfolge “Python” mit “for beginners” addieren?\nErzeugen Sie eine Zeichenfolge, die 10 mal die Zeichenfolge “tick tack”.\nWelche Zeichenfolge ist kleiner, “Aachen” oder “Bern”. Warum ist das so, wie werden Zeichenfolgen verglichen?\nGeben Sie den Dateipfad aus: “~_daten”\n\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nTipp 2.2: Musterlösung Aufgaben Zeichenfolgen\n\n\n\n\n\n\n\n\n\n\n\nVariablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen müssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable ändert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable ändern, um das Ergebnis einer Operation aufnehmen zu können. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‘float’ zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enthält Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Fließkommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Fließkommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder übersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind für jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag für Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abträglich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nFür die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausführlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben lässt. Denn Programmcode wird deutlich häufiger gelesen als geschrieben. Können Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern können.\nFalls Sie sich nicht erinnern können, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Auflösung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAuflösung\n\n\n\n\n\n\nprint(type(var_3), type(variable1), type(a))\n\n&lt;class 'bool'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich “sprechende”, das heißt selbsterklärende, Variablennamen zu vergeben. Unter selbsterklärenden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einfließen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchlüsselwörter und Funktionsnamen\n\n\n\nIn Python reservierte Schlüsselwörter und Funktionsnamen sind ungeeignete Variablennamen. Während Python die Wertzuweisung zu Schlüsselwörtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen problemslos neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese natürlich nicht mehr. In diesem Fall müssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\n\n\n\n\nAufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit 𝗍 in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung für folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen für \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, überlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte können sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable für den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschließlich Einheiten) ein.\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nTipp 2.3: Musterlösung Aufgaben Variablen\n\n\n\n\n\n\n\n\n\n(Arnold 2023a)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "python-code.html#ausgabe-formatieren",
    "href": "python-code.html#ausgabe-formatieren",
    "title": "2  Python-Code",
    "section": "2.3 Ausgabe formatieren",
    "text": "2.3 Ausgabe formatieren\nMit sogenannten f-Strings können formatierte Zeichenketten erstellt werden. Formatierte Zeichenketten werden mit einem vorgesetzten f vor den Anführungsstrichen erstellt. Werte und Variablen können durch Platzhalter eingesetzt werden, die mit geschweiften Klammern {} angegeben und mit Formattierungsinformationen versehen werden. Das Formatierungsformat innerhalb der geschweiften Klammer ist, vereinfacht dargestellt:\n{Variablenname:PlatzbedarfAusgabetyp}\nEin f-String mit Platzhaltern ohne Formatierungsinformationen:\n\nzahl1 = 5\nzahl2 = 7\nverhältnis = zahl1 / zahl2\nprint(f\"Das Verhältnis von {zahl1} zu {zahl2} ist {verhältnis}.\")\n\nDas Verhältnis von 5 zu 7 ist 0.7142857142857143.\n\n\nDie Anzahl der darzustellenden Nachkommastellen kann wie folgt festgelegt werden: {verhältnis:.2f}.\n\n: leitet die Formatierungsbefehle ein.\n. gibt an, dass Formatierungsinformationen für die Darstellung hinter dem Dezimaltrennzeichen folgen.\n2 ist der Wert für die darzustellenden Nachkommastellen.\nf spezifiziert die Darstellung einer Gleitkommazahl ‘float’.\n\n\nprint(f\"Das Verhältnis von {zahl1} zu {zahl2} ist {verhältnis:.2f}.\")\n\nDas Verhältnis von 5 zu 7 ist 0.71.\n\n\nDas gleiche ist mit einem Wert möglich:\n\nprint(f\"Das Verhältnis ist genauer {0.7142857142857143:.3f}.\")\n\nDas Verhältnis ist genauer 0.714.\n\n\nEin Wert für die insgesamt darzustellenden Stellen wird vor dem Dezimaltrennzeichen übergeben {verhältnis:7.2f} bzw. inklusive führender Nullen {verhältnis:07.2f}:\n\nprint(f\"Das Verhältnis von {zahl1} zu {zahl2} ist {verhältnis:7.2f}.\")\nprint(f\"Das Verhältnis ist genauer {0.7142857142857143:07.3f}.\")\n\nDas Verhältnis von 5 zu 7 ist    0.71.\nDas Verhältnis ist genauer 000.714.\n\n\nDas Dezimaltrennzeichen zählt als eine Stelle.\nHäufig verwendete Formatierung sind:\n\nganze ZahlenGleitkommazahlenZeichenketten\n\n\nGanze Zahlen haben den Ausgabetyp d.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nnd\nn-Stellen werden für die Ausgabe verwendet\n\n\n0nd\nAusgabe von n-Stellen, wobei die Leerstellen mit Nullen aufgefüllt werden.\n\n\n+d\nAusgabe des Vorzeichens auch bei positiven Zahlen\n\n\n\n\n\nGleitkommazahlen haben die Ausgabetypen f und e.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\n.mf\nm-Stellen werden für die Nachkommastellen genutzt.\n\n\nn.mf\nInsgesamt werden n-Stellen verwendet, wobei m-Stellen für die Nachkommastellen genutzt werden.\n\n\nn.me\nGenauso, aber die Ausgabe erfolgt in exponentieller Schreibweise.\n\n\n\n\n\nZeichenketten haben den Ausgabetyp s.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nns\nInsgesamt werden n-Stellen verwendet.\n\n\n&lt;ns, &gt;ns, ^ns\nGenauso, jedoch wird die Zeichenkette linksbündig, rechtsbündig bzw. zentriert platziert.\n\n\n\n\n\n\nEine Auflistung aller verfügbaren Ausgabetypen findet sich in der Python Dokumentation.\n\nAufgaben Ausgabe\n\n“Gleitkommazahlen können natürlich, z. B. {1015.39:12.4f}, oder wissenschaftlich, {1015.39:e}, dargestellt werden.”\n\n\nVerändern Sie die natürliche Schreibwese so, dass nur noch eine Stelle nach dem Komma angezeigt wird. Was fällt auf?\nVerändern Sie die wissenschaftliche Schreibweise so, dass anstelle von e die Zehnerbasis als E geschrieben wird.\n\n\nWandeln Sie die Zahl 1015.39 in eine Zeichenkette um und stellen Sie diese mit 12 Stellen rechtsbündig dar.\nGeben Sie mit Hilfe der formatierten Zeichenketten eine Tabelle aus, welche die Spalten \\(x\\), \\(x^2\\) und \\(x^3\\) für ganze Zahlen zwischen -2 und 2 auflistet.\n\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nTipp 2.4: Musterlösung Ausgabe\n\n\n\n\n\n\n\n\n\n(Arnold 2023b)\n\n\n\n\nArnold, Simone. 2023a. „Datenanalyse mit Python. Datentypen und Grundlagen.“ Fachhochschule Dortmund.\n\n\n———. 2023b. „Datenanalyse mit Python. Funktionen Module Dateien.“ Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "funktionen.html",
    "href": "funktionen.html",
    "title": "3  Funktionen: Grundlagen",
    "section": "",
    "text": "3.1 Funktionen und Methoden\nIn Python gibt es zwei Arten von Funktionen: Funktionen und Methoden. In diesem Kapitel werden hauptsächlich Funktionen behandelt. Im Kapitel Querverweis wird der Umgang mit Methoden vertieft.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#funktionen-und-methoden",
    "href": "funktionen.html#funktionen-und-methoden",
    "title": "3  Funktionen: Grundlagen",
    "section": "",
    "text": "Funktionen\nFunktionen werden über ihren Funktionsnamen gefolgt von runden Klammern () aufgerufen. Ein Beispiel ist die Funktion print(), der Objekte unabhängig von ihrem Datentyp übergeben werden können.\n\nvar_str = 'ABC'\nvar_int = 26\nvar_bool = True\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_str))\nprint(\"Die Variable var_2 hat den Typ\", type(var_int))\nprint(\"Die Variable var_3 hat den Typ\", type(var_bool))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nFunktionen müssen immer einen Wert zurückgeben. Wenn Funktionen keinen Wert zurückgeben können oder sollen, wird der Wert None zurückgegeben, der nicht existente Werte kennzeichnet.\n\nres = print( 15 )\nprint(res)\n\n15\nNone\n\n\n\n\nMethoden\nMethoden sind eine Besonderheit objektorientierter Programmiersprachen. Im vorherigen Kapitel wurde erläutert, dass in Python Variablen bzw. Objekte abhängig von den in ihnen gespeicherten Werte einen passenden Datentyp erhalten. Methoden sind Funktionen, die zu einem bestimmten Datentyp gehören. Methoden werden getrennt durch einen Punkt . hinter Objekten mit ihrem Namen aufgerufen: Variable.Methode bzw. (Wert).Methode. Die Methoden .upper(), .lower() und .title sind für Zeichenfolgen definierte Methoden.\n\ntoller_text = \"Python 3.12 ist großartig.\"\n\nprint(toller_text)\nprint(toller_text.upper())\nprint(toller_text.lower())\nprint(toller_text.title(), \"\\n\")\n\nprint((\"Mit in Klammern gesetzten Werten klappt es auch.\").upper())\n\nPython 3.12 ist großartig.\nPYTHON 3.12 IST GROSSARTIG.\npython 3.12 ist großartig.\nPython 3.12 Ist Großartig. \n\nMIT IN KLAMMERN GESETZTEN WERTEN KLAPPT ES AUCH.\n\n\nAuf Objekte mit einem unpassenden Datentyp können Methoden wie .lower() nicht angewendet werden.\n\ntry:\n  var_int.upper()\nexcept AttributeError as error:\n  print(error)\n\n'int' object has no attribute 'upper'",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#funktionen-schreiben",
    "href": "funktionen.html#funktionen-schreiben",
    "title": "3  Funktionen",
    "section": "3.3 Funktionen schreiben",
    "text": "3.3 Funktionen schreiben\nIch glaube, hier oder spätestens im nächsten Kapitel sollte das Lesen der Dokumentation trainiert werden?!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#aufruf",
    "href": "funktionen.html#aufruf",
    "title": "3  Funktionen",
    "section": "3.2 Aufruf",
    "text": "3.2 Aufruf\nFunktionen werden über ihren Funktionsnamen gefolgt von runden Klammern () aufgerufen. Dies kennen Sie bereits aus den vorherigen Kapiteln. Getrennt durch Kommata können mehrere Argumente übergeben werden.\n\nprint(\"Die Funktion print wurde schon oft gezeigt.\", \"Das zweite Funktionsargument.\")\n\nDie Funktion print wurde schon oft gezeigt. Das zweite Funktionsargument.\n\n\nArgumente steuern die Programmausführung. Die für die Funktion print() verfügbaren Argumente stehen in der Dokumentation der Funktion.\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n… erklären: verpflichtende und optionale Argumente, positionale und Schlüsselwortargumente\n\nverpflichtende und optionale Argumente Was gibt es für Argumente: verpflichtende und optionale Argumente: Welche Argumente muss man übergeben (die ohne =), welche kann man übergeben (die mit =).\npositionale und Schlüsselwortargumente\n\nAm Beispiel print: Das Argument *objects nimmt die Elemente entgegen, die mit print ausgegeben werden sollen. Das Sternchen * signalisiert zum einen, dass eine beliebige Anzahl an Argumenten an das Argument *objects übergeben werden kann. Zum anderen zeigt das Sternchen * an, dass es sich um ein positionales Argument handelt. Die Elemente, die mit print ausgegeben werden sollen, müssen an erster Stelle stehen.\n… demgegenüber Schlüsselwortargumente die können überall stehen - in diesem Fall außer an der ersten Stelle, denn dort muss das positionale Objekt *objects stehen.\n\nDie Eingabe von Daten erfolgt mit dem Funktionsaufruf Verarbeitung: Steuerung über Argumente Ausgabe: return-statement\n\nFunktionen …\n\nhaben einen Funktionsnamen gefolgt von runden Klammern (), über den Sie aufgerufen werden.\n\nmüssen immer einen Wert zurückgeben. Wenn Funktionen keinen Wert zurückgeben können oder sollen, wird der Wert None zurückgegeben, der nicht existente Werte kennzeichnet.\n\nwichtiger Tipp: die vorausgefüllten Werte sind leider nicht immer die default-Werte",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#argumente-gehören-zum-aufruf",
    "href": "funktionen.html#argumente-gehören-zum-aufruf",
    "title": "3  Funktionen",
    "section": "3.3 Argumente gehören zum Aufruf",
    "text": "3.3 Argumente gehören zum Aufruf\nFunktionen können Argumente entgegennehmen, die die Programmausführung steuern.\n\n\n\n\n\n\nTipp 3.2: Dokumentation\n\n\n\n\n\nverpflichtende und optionale Argumente: Welche Argumente muss man übergeben (die ohne =), welche kann man übergeben (die mit =). Einige Funktionen haben dutzende dokumentierte Argumente und können über die Platzhalter *args und **kwargs weitere Argumente aufnehmen. Bedeutung des Sterns: (Aus glob:) Das Argument pathname kann als Schlüsselwort oder positional übergeben werden, die übrigen Argumente müssen als Schlüsselwort übergeben werden (dies signalisiert das Zeichen *) Das *, das positionale Argumente von Schlüsselwortargumenten trennt, kommt in der Dokumentation immer nur einmal vor. Erklärung *args und **kwargs siehe https://book.pythontips.com/en/latest/args_and_kwargs.html\nwichtig ist auch: leider sind die Startwerte in der Funktionsdokumentation nicht (immer) die default-Werte — da habe ich ein Beispiel in meiner zuerledigen Liste — daraus kann man gleich eine Aufgabe machen, den default-Wert heraussuchen zu lassen.\n\n\n\nIn den bisherigen Kapiteln haben Sie bereits die Funktion print() kennengelernt, mit der (formatierte) Zeichenfolgen, Variablen und Werte ausgegeben werden können.\n\nprint(\"Die Funktion print gibt Zeichenfolgen, Variablen und Werte aus.\")\n\nDie Funktion print gibt Zeichenfolgen, Variablen und Werte aus.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#ausgabe",
    "href": "funktionen.html#ausgabe",
    "title": "3  Funktionen",
    "section": "3.3 Ausgabe",
    "text": "3.3 Ausgabe\nFunktionen müssen immer einen Wert zurückgeben. Wenn Funktionen keinen Wert zurückgeben können oder sollen, wird der Wert None zurückgegeben, der nicht existente Werte kennzeichnet.\n\nres = print( 15 )\nprint(res)\n\n15\nNone",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#eigene-funktionen-schreiben",
    "href": "funktionen.html#eigene-funktionen-schreiben",
    "title": "3  Funktionen",
    "section": "3.4 Eigene Funktionen schreiben",
    "text": "3.4 Eigene Funktionen schreiben\nIt’s important to note that the optional argument must always appear after any required arguments when defining the function\nusing positional Arguments\n*args wird verwendet, um eine variable Anzahl von nicht-schlüsselwortlichen Argumenten zu empfangen. Innerhalb der Funktion wird args als eine Tuple behandelt, die alle übergebenen Argumente enthält.\nusing Keyword Arguments in Python\n**kwargs ist ähnlich wie *args, aber es wird verwendet, um eine variable Anzahl von schlüsselwortbasierten Argumenten zu empfangen. Innerhalb der Funktion wird kwargs als ein Dictionary behandelt.\nKeyword arguments allow developers to specify which arguments should have which values when calling a Python function. This is especially useful if order isn’t important. To use keyword arguments, pass in a dictionary with the keyword and its associated value as an argument. For example:\nmy_dict = {“optional_arg1”: 42} func_name(required_arg1, required_arg2, **my_dict)\nAusgabe: return-statement\n\nKontrollstrukturen\n\nFallunterscheidung if\n\n\nSchleifen while, for\n\n\n\nlambda",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html",
    "href": "sammeltypen.html",
    "title": "4  Sammeltypen",
    "section": "",
    "text": "4.1 Listen\nListen können eine flexible Anzahl von Elementen beliebigen Typs beinhalten. In Python enthalten Listen nicht wirklich Daten, sondern bestehen aus Zeigern auf die Speicherorte der enthaltenen Elemente. Bei der Definition einer Liste, werden die Elemente durch [] eingeklammert und mit Kommata , getrennt.\ntext_variable = 'abc'\n\nliste1 = [1, 'xy', True, text_variable]\nprint(liste1)\n\n# Listen können auch Listen enthalten\nliste2 = [None, liste1]\nprint(liste2)\n\n[1, 'xy', True, 'abc']\n[None, [1, 'xy', True, 'abc']]\nWie alle Typen in Python, werden Listen durch Zuweisung erstellt. Eine leere Liste kann durch Zuweisung von [] erstellt werden.\nleere_liste = []\nprint(leere_liste)\n\n[]\nWie Zeichenfolgen können Listen durch den Operator ‘+’ verkettet werden.\nverkettete_liste = liste1 + liste2\nprint(verkettete_liste)\n\n[1, 'xy', True, 'abc', None, [1, 'xy', True, 'abc']]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#funktionen-und-methoden-1",
    "href": "funktionen.html#funktionen-und-methoden-1",
    "title": "3  Funktionen",
    "section": "3.4 Funktionen und Methoden",
    "text": "3.4 Funktionen und Methoden\nZahlen: Funktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()… ein paar Funktionen für die Ausgabe von strings ohne ’’ und ohne ,\n\nprint(format(0.1, ‘.17g’)) # 17 signifikante Stellen\nprint(format(0.1, ‘.17f’)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nStrings: Methoden .lower(), .upper(), .title() https://www.w3schools.com/python/python_ref_string.asp\nAls nächstes Kapitel: Programmsteuerung\n\nFallunterscheidung if\n\n\nSchleifen while, for",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#argumente",
    "href": "funktionen.html#argumente",
    "title": "3  Funktionen",
    "section": "3.2 Argumente",
    "text": "3.2 Argumente\nVielen Funktionen und Methoden können getrennt durch Kommata mehrere Argumente übergeben werden. Argumente steuern die Programmausführung. Argumente werden auch als Parameter bezeichnet.\n\nprint(\"Die Funktion print wurde schon oft gezeigt.\", \"Das ist das zweite Argument.\")\n\nDie Funktion print wurde schon oft gezeigt. Das ist das zweite Argument.\n\n\nDie für die Funktion print() verfügbaren Argumente stehen in der Dokumentation der Funktion.\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n\nArgumente ohne vorangestelltes Gleichheitszeichen = müssen beim Funktions- bzw. Methodenaufruf übergeben werden. Argumente mit vorangestellten Gleichheitszeichen = können beim Aufruf übergeben werden, es handelt sich um optionale Argumente.\nArgumente können in Python entweder als positionales Argument übergeben werden, das heißt Python ordnet Eingaben entsprechend ihrer Reihenfolge Argumenten zu. Alternativ können Argumente als Schlüsselwort übergeben werden, die Zuordnung von Eingaben erfolgt über den Namen des Arguments.\ndas vorangestellte Sternchen vor einem Argument *objects entspricht einem Platzhalter für eine beliebige Anzahl von Argumenten.\n\n*objects ist also ein positionales Argument (es steht immer an erster Stelle), das keinen Standardwert hat und dem beliebig viele Argumente übergeben werden können (n Eingaben stehen also an den ersten n-Stellen). Dadurch, dass beliebig viele Argumente übergeben werden können, funktioniert auch ein leerer Aufruf der Funktion print(), obwohl das Argument *objects verpflichtend übergeben werden muss.\nDie weiteren Argumente der Funktion print können als Schlüsselwort übergeben werden. Die Werte hinter dem Gleichheitszeichen zeigen die Standardwerte (default value) der Argumente an. Diese werden verwendet, wenn ein Argument nicht explizit beim Aufruf übergeben wird.\nGeben Sie die drei Werte 1, 2 und 3 mit print() aus. Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt aussieht:\n\n\n1_x_2_x_3\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nprint(1, 2, 3, sep = \"_x_\")\n\n\n\n\n\n\n\n\n\n\nTipp 3.2: Standardwert None\n\n\n\n\n\nEinige Funktionen verwenden das Schlüsselwort None zur Kennzeichnung des Standardwerts. Ein Beispiel ist die NumPy-Funktion numpy.loadtxt().\nnumpy.loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, *, quotechar=None, like=None)\nFür das Argument delimiter ist als Standardwert das Schlüsselwort None eingetragen. Wie der Funktionsbeschreibung zu entnehmen ist, ist der Standartwert tatsächlich das Leerzeichen: “The default is whitespace.”\nAuch das Argument usecols hat den Standarwert None. Dies bedeutet aber: “The default, None, results in all columns being read.”\n\n\n\nVielen Funktionen können beliebig viele Argumente positional oder als Schlüsselwort übergeben werden. Im Allgemeinen wird dies durch die Schlüsselwörter *args (positionale Argumente) und **kwargs (key word arguments, Schlüsselwortargumente) angezeigt (weitere Informationen dazu finden Sie hier).\n\n\n\n\n\n\nTipp 3.3: Bedeutung der Argumente * und /\n\n\n\n\n\nDie Argumente * und / zeigen an, welche Argumente positional und welche per Schlüsselwort übergeben werden können bzw. müssen.\n\n\n\n\n\n\n\n\n\nLinke Seite\nTrennzeichen\nRechte Seite\n\n\n\n\nnur positionale Argumente\n/\npositionale oder Schlüsselwortargumente\n\n\npositionale oder Schlüsselwortargumente\n*\nnur Schlüsselwortargumente\n\n\n\nhttps://realpython.com/python-asterisk-and-slash-special-parameters/\nBeide Steuerzeichen können innerhalb einer Funktionsdefinition vorkommen, allerdings nur in der Reihenfolge / und *. Im umgekehrten Fall wäre es unmöglich, Argumente zu übergeben.\n\nEin Beispiel ist die Funktion glob aus dem gleichnamigen Modul.\nglob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)\nDas Argument pathname kann positional (an erster Stelle) oder als Schlüsselwort übergeben werden. Die übrigen Argumente müssen als Schlüsselwortargumente übergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#aufgaben-funktionen",
    "href": "funktionen.html#aufgaben-funktionen",
    "title": "3  Funktionen: Grundlagen",
    "section": "3.3 Aufgaben Funktionen",
    "text": "3.3 Aufgaben Funktionen\n\nRichtig oder falsch: Methoden stehen abhängig vom Datentyp eines Werts oder eines Objekts zur Verfügung.\nGeben Sie die drei Werte 1, 2 und 3 mit print() aus. Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt aussieht:\n\n\n\n1_x_2_x_3\n\n\n\nSchlagen Sie in der Dokumentation die Funktion bool() nach.\n\n\nWelche Parameter nimmt die Funktion entgegen und welche davon sind optional?\nWelche Argumente werden positional und welche als Schlüsselübergeben? Ist die Art der Übergabe wählbar oder festgelegt?\n\n\n\n\n\n\n\nLösungen\n\n\n\n\n\nAufgabe 1: richtig\nAufgabe 2\n\nprint(1, 2, 3, sep = \"_x_\")\n\nAufgabe 3: Die Funktion bool() hat ein optionales Argument object mit dem Standardwert False. Das Argument muss positional übergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#kontrollstrukturen",
    "href": "funktionen.html#kontrollstrukturen",
    "title": "3  Funktionen",
    "section": "4.1 Kontrollstrukturen",
    "text": "4.1 Kontrollstrukturen\n\nFallunterscheidung if\n\n\nSchleifen while, for",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#parameter",
    "href": "funktionen.html#parameter",
    "title": "3  Funktionen: Grundlagen",
    "section": "3.2 Parameter",
    "text": "3.2 Parameter\nVielen Funktionen und Methoden können getrennt durch Kommata mehrere Parameter übergeben werden. Parameter steuern die Programmausführung. Die für die Funktion print() verfügbaren Parameter stehen in der Dokumentation der Funktion. Die Werte, die als Parameter übergeben werden, werden Argumente genannt (Python-Dokumentation).\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n*objects, sep, end, file und flush sind die Parameter der Funktion print().\n\nParameter ohne vorangestelltes Gleichheitszeichen = müssen beim Funktions- bzw. Methodenaufruf übergeben werden. Parameter mit vorangestellten Gleichheitszeichen = können beim Aufruf übergeben werden, es handelt sich um optionale Parameter.\nDie Werte hinter dem Gleichheitszeichen zeigen die Standardwerte (default value) der Parameter an. Diese werden verwendet, wenn ein Argument nicht explizit beim Aufruf übergeben wird.\n\n\n\n\n\n\n\nTipp 3.2: Ausnahmen bei Standardwerten\n\n\n\n\n\nBei den in der Funktionsdefinition genannten Werten handelt es sich nicht immer um die tatsächlichen Standardwerte. Es empfiehlt sich deshalb, wenn eine Funktion verwendet wird, die Beschreibung der Parameter zu lesen.\nEinige Funktionen verwenden das Schlüsselwort None zur Kennzeichnung des Standardwerts. Der Wert None dient dabei als Platzhalter. Ein Beispiel ist die NumPy-Funktion numpy.loadtxt().\nnumpy.loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, /\n              skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, /\n              *, quotechar=None, like=None)\n\nFür den Parameter delimiter ist als Standardwert das Schlüsselwort None eingetragen. Wie der Funktionsbeschreibung zu entnehmen ist, ist der Standartwert tatsächlich das Leerzeichen: “The default is whitespace.”\nAuch der Parameter usecols hat den Standarwert None: “The default, None, results in all columns being read.”\n\nEin weiteres Beispiel ist die Funktion pandas.read_csv(). Einige Argumente haben den Standardwert &lt;no_default&gt;. (Im Folgenden werden nur ausgewählte Parameter gezeigt).\npandas.read_csv(sep=&lt;no_default&gt;, verbose=&lt;no_default&gt;)\nAus der Beschreibung können die tatsächlichen Standardwerte abgelesen werden:\nsep : str, default ‘,’\nverbose : bool, default False\n\n\n\n\nArgumente können in Python entweder als positionales Argument übergeben werden, das heißt, Python erwartet Argumente in einer feststehenden Reihenfolge entsprechend der Parameter der Funktionsdefinition. Alternativ können Argumente als Schlüsselwort übergeben werden, die Zuordnung von Eingaben erfolgt über den Namen des Parameters. Standardmäßig können Argumente positional oder per Schlüsselwort übergeben werden. Abweichungen davon werden durch die Symbole * und / gekennzeichnet (siehe folgenden Tipp).\n\n\n\n\n\n\n\nTipp 3.3: Positionale und Schlüsselwortargumente, *args und **kwargs\n\n\n\n\n\nDie Symbole * und / zeigen an, welche Parameter positional und welche per Schlüsselwort übergeben werden können bzw. müssen.\n\n\n\n\n\n\n\n\n\nLinke Seite\nTrennzeichen\nRechte Seite\n\n\n\n\nnur positionale Argumente\n/\npositionale oder Schlüsselwortargumente\n\n\npositionale oder Schlüsselwortargumente\n*\nnur Schlüsselwortargumente\n\n\n\n(https://realpython.com/python-asterisk-and-slash-special-parameters/)\n\n \nEin Beispiel für das Trennzeichen * ist die Funktion glob aus dem gleichnamigen Modul. Der Parameter pathname kann positional (an erster Stelle) oder als Schlüsselwort übergeben werden. Die übrigen Parameter müssen als Schlüsselwortargumente übergeben werden.\nglob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)\nBeide Steuerzeichen können innerhalb einer Funktionsdefinition vorkommen, allerdings nur in der Reihenfolge / und *. Im umgekehrten Fall wäre es unmöglich, Argumente zu übergeben. Ein Beispiel ist die Funktion sorted. Der erste Parameter muss positional übergeben werden, die Parameter key und reverse müssen als Schlüsselworte übergeben werden.\nsorted(iterable, /, *, key=None, reverse=False)¶\n\n\n\n\n\n\nAusnahmen\n\n\n\nEinige Funktionen weichen von der Systematik ab, beispielsweise die Funktionen min() und max(). Diese sind (u. a.) in der Form definiert:\nmin(iterable, *, key=None)\nmax(iterable, *, key=None)\nBeide Funktionen akzeptieren den Parameter iterable aber nicht als Schlüsselwort.\n\n\nVielen Funktionen können beliebig viele Argumente positional oder als Schlüsselwort übergeben werden. Im Allgemeinen wird dies durch die Schlüsselwörter *args (positionale Argumente) und **kwargs (key word arguments, Schlüsselwortargumente) angezeigt. Der Unterschied wird durch das eine bzw. die beiden Sternchen markiert, die Schlüsselwörter selbst sind austauschbar (wie bei der Funktion print(*objects)). Das Schlüsselwort *args entspricht zugleich dem Symbol * in der Funktionsdefinition, d. h. rechts davon dürfen nur Schlüsselwortargumente stehen. Weitere Informationen dazu finden Sie hier.\n\n\n\nIn der Funktionsdefinition von print() ist *objects also ein positionaler Parameter (dieser steht immer an erster Stelle), der keinen Standardwert hat und dem beliebig viele Argumente übergeben werden können (n Eingaben stehen an den ersten n-Stellen). Die weiteren Parameter der Funktion print() sind optional und müssen als Schlüsselwort übergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#aufgaben-funktionen-und-methoden",
    "href": "funktionen.html#aufgaben-funktionen-und-methoden",
    "title": "3  Funktionen und Methoden",
    "section": "3.3 Aufgaben Funktionen und Methoden",
    "text": "3.3 Aufgaben Funktionen und Methoden\n\nRichtig oder falsch: Methoden stehen abhängig vom Datentyp eines Werts oder eines Objekts zur Verfügung.\nGeben Sie die drei Werte 1, 2 und 3 mit print() aus. Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt aussieht:\n\n\n\n1_x_2_x_3\n\n\n\nSchlagen Sie die Funktion bool() nach.\n\n\nWelche Parameter nimmt die Funktion entgegen und welche davon sind optional?\nWelche Argumente werden positional und welche als Schlüsselübergeben? Ist die Art der Übergabe wählbar oder festgelegt?\n\n\nErstellen Sie eine Variable vom Datentyp ‘str’.\n\n\n\n\n\n\n\nLösungen\n\n\n\n\n\nAufgabe 1: richtig\nAufgabe 2\n\nprint(1, 2, 3, sep = \"_x_\")\n\nAufgabe 3: Die Funktion bool() hat ein optionales Argument object mit dem Standardwert False. Das Argument muss positional übergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen und Methoden</span>"
    ]
  },
  {
    "objectID": "funktionen.html#flusskontrolle",
    "href": "funktionen.html#flusskontrolle",
    "title": "3  Funktionen: Grundlagen",
    "section": "3.4 Flusskontrolle",
    "text": "3.4 Flusskontrolle\nDie Flusskontrolle ermöglicht es, die Ausführung von Programmteilen zu steuern. Anweisungen können übersprungen oder (mehrfach) ausgeführt werden.\n\nAbzweigungen\nAbzweigungen ermöglichen eine Fallunterscheidung, bei der verschiedene Teile des Skripts ausgeführt werden.\nIn Python werden Abzweigungen mit dem if Schlüsselwort eingeleitet. Dieses wird von der Abzweigbedingung gefolgt und mit einem Doppelpunkt : abgeschlossen. Falls die Abzweigbedingung wahr ist, wird der eingerückte Anweisungsblock ausgeführt.\nif Bedingung:\n    Anweisungsblock\n\n# Beispiel: Zahl kleiner als ein Schwellwert\n\na = 7\nif a &lt; 10:\n    print( 'Die Zahl', a, 'ist kleiner als 10.')\n\nDie Zahl 7 ist kleiner als 10.\n\n\nEs ist auch möglich einen alternativen Anweisungsblock zu definieren, welcher ausgeführt wird, wenn die Bedingung falsch ist. Dieser wird mit dem else Schlüsselwort umgesetzt.\nif Bedingung:\n    # Bedingung ist wahr\n    Anweisungsblock\nelse:\n    # Bedingung ist falsch\n    Anweisungsblock\n\n# Beispiel: Zahl kleiner als ein Schwellwert mit alternativer Ausgabe\n\na = 13\nif a &lt; 10:\n    print( 'Die Zahl', a, 'ist kleiner als 10.')\nelse:\n    print( 'Die Zahl', a, 'ist nicht kleiner als 10.')\n\nDie Zahl 13 ist nicht kleiner als 10.\n\n\nEs können auch mehrere Bedingungen übergeben werden.\n\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20\n\na = 1\nif a &lt; 20 and a &gt; 10:\n    print( 'Die Zahl', a, 'liegt zwischen 10 und 20.')\nelse:\n    print( 'Die Zahl', a, 'liegt nicht zwischen 10 und 20.')\n\nDie Zahl 1 liegt nicht zwischen 10 und 20.\n\n\nSchließlich können mehrere alternative Bedingungen geprüft werden. Dies ist zum einen durch das Verschachteln von Abzweigungen möglich.\n\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit verschachtelten Abzweigungen\n\na = 12\nif a &gt; 10:\n    print( 'Die Zahl', a, 'ist größer als 10.' )\n    \n    if a &lt; 20:\n        print( 'Die Zahl', a, 'ist kleiner als 20.' )\n        print( 'Damit liegt die Zahl zwischen 10 und 20.')\n    else:\n        print( 'Die Zahl', a, 'ist größer als 20 und liegt nicht im gesuchten Wertebereich.' )\nelse:\n        print( 'Die Zahl', a, 'ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.' )\n\nDie Zahl 12 ist größer als 10.\nDie Zahl 12 ist kleiner als 20.\nDamit liegt die Zahl zwischen 10 und 20.\n\n\nZum anderen ist dies mit dem Schlüsselwort elif möglich.\n\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit elif\n\na = 112\nif a &lt; 20 and a &gt; 10:\n  print('Die Zahl', a, 'liegt zwischen 10 und 20.')\nelif a &lt; 10:\n  print('Die Zahl', a, 'ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.' )\nelif a &gt; 20 and a &lt;= 100:\n  print('Die Zahl', a, 'ist größer als 20, aber nicht größer als 100.')\nelif a &gt; 20 and a &lt;= 1000:\n  print('Die Zahl', a, 'ist größer als 20, aber nicht größer als 1000.')\nelse:\n  print('Die Zahl', a, 'liegt nicht zwischen 10 und 20 und ist größer als 1000.')\n\nDie Zahl 112 ist größer als 20, aber nicht größer als 1000.\n\n\n\n\nSchleifen\nSchleifen ermöglichen es, Anweisungen zu wiederholen. In Python können while- und for-Schleifen definiert werden. Beide benötigen:\n\neinen Schleifenkopf, welcher die Ausführung des Anweisungsblocks steuert, und\neinen Anweisungsblock, also eine Gruppe von Anweisungen, welche bei jedem Schleifendurchlauf ausgeführt werden.\n\nDie while-Schleife kommt mit nur einer Bedingung im Schleifenkopf aus und ist die allgemeinere von beiden. Jede for-Schleife kann zu einer while-Schleife umgeschrieben werden (indem ein Zähler in den Anweisungsblock integriert wird.) Welcher der beiden Typen verwendet wird, hängt von der jeweiligen Aufgabe ab.\n\nwhile-Schleifen\nEine while-Schleife führt den Anweisungsblock immer wieder aus, solange die Ausführbedingung wahr ist. Die Schleife wird mit dem Schlüsselwort while eingeleitet, gefolgt von der Ausführbedingung. Dieser Schleifenkopf wird mit einem Doppelpunkt : abgeschlossen. Darunter wird der eingerückte Anweisungsblock definiert.\nwhile Bedingung:\n    Anweisungsblock\nBeim Beginn der Schleife und nach jedem Durchlauf wird die Bedingung geprüft. Ist sie wahr, so wird der Anweisungsblock ausgeführt, wenn nicht, ist die Schleife beendet und die nächste Anweisung außerhalb der Schleife wird ausgeführt.\n\n# Beispiel: Erhöhen eines Variablenwertes\n\n# Setzte Startwert\na = 5\n\n# Definiere Schleife, welche solange ausgeführt \n# wird, wie a kleiner als 10 ist\nwhile a &lt;= 10:\n    # Anweisungsblock der Schleife:\n    \n    # 1. Ausgabe des aktuellen Werts von a \n    print('aktueller Wert von a', a)\n    \n    # 2. Erhöhung von a um Eins\n    a += 1\n\n# Ausgabe des Wertes nach der Schleife\nprint('Wert von a nach der Schleife', a)\n\naktueller Wert von a 5\naktueller Wert von a 6\naktueller Wert von a 7\naktueller Wert von a 8\naktueller Wert von a 9\naktueller Wert von a 10\nWert von a nach der Schleife 11\n\n\n\n\nfor-Schleifen\nWährend die while-Schleife ausgeführt wird, solange eine Bedingung erfüllt ist, wird die for-Schleife über eine Laufvariable gesteuert, die eine Sequenz durchläuft. Die Syntax sieht wie folgt aus:\nfor Laufvariable in Sequenz:\n  Anweisungsblock\nZur Definition des Schleifenkopf gehören die beiden Schlüsselworte for und in und der Kopf wird mit einem Doppelpunkt : abgeschlossen. Auch hier wird der Anweisungsblock eingerückt. Die Sequenz wird mit einem range-Objekt erstellt, das mit der Funktion range(start = 0, stop, step = 1) erzeugt wird. range() nimmt ganzzahlige Werte als positionale Argumente entgegen und erzeugt Ganzzahlen von start bis nicht einschließlich stop mit der Schrittweite step. Dabei ist wichtig, dass Python exklusiv zählt, das heißt, Python beginnt standarmäßig bei 0 zu zählen und der als Argument stop übergebene Wert wird nicht mitgezählt.\nDa range() ein range-Objekt zurückgibt, kann mit print() nicht unmittelbar die erwartete Ausgabe erzeugt werden.\n\n# range(start = 1, stop = 5) - step wird nicht übergeben, es gilt der Standardwert step = 1\nprint(range(1, 5), type(range(1, 5)))\n\nrange(1, 5) &lt;class 'range'&gt;\n\n\nDieses Verhalten wird faule Auswertung (lazy evaluation) genannt: Die Werte des range-Objekts werden erst erzeugt, wenn Sie benötigt werden. Im Folgenden Code wird das range-Objekt mit einer Schleife durchlaufen und für jeden Durchlauf der Wert der Laufvariable i ausgegeben.\n\nfor i in range(1, 5):\n  print(i)\n\n1\n2\n3\n4\n\n\nMit dem Parameter step kann die Schrittweite gesteuert werden.\n\nfor i in range(1, 15, 3):\n  print(i)\n\n1\n4\n7\n10\n13\n\n\nNützlich ist die Ausgabe des range-Objekts in eine Liste oder in ein Tupel, Sammeltypen, die im nächsten Kapitel behandelt werden.\n\n# Ausgabe der geraden Zahlen 1-10 in eine Liste\nprint(\"Liste:\", list(range(2, 11, 2)))\n\n# Ausgabe der ungeraden Zahlen 1-10 in ein Tupel\nprint(\"Tupel:\", tuple(range(1, 11, 2)))\n\nListe: [2, 4, 6, 8, 10]\nTupel: (1, 3, 5, 7, 9)\n\n\nstart und stop können auch negativ sein, step muss immer größer 0 sein.\n\nfor i in range(-5, -1):\n  print(i)\n\n-5\n-4\n-3\n-2\n\n\nstop muss immer größer als start sein. Um eine absteigende Zahlenfolge zu erzeugen, wird die Funktion reversed(sequenz) verwendet.\n\n# Die Ausgabe bleibt leer\nprint(list(range(5, 0)))\n\n# Mit der Funktion reversed geht es\nprint(list(reversed(range(0, 5))))\n\n[]\n[4, 3, 2, 1, 0]\n\n\n\n\n\nAufgaben Flusskontrolle\n\nSchreiben Sie ein Programm, dass von 1 bis 25 und von 38 bis 50 zählt und jeden Wert, der ganzzahlig durch 7 teilbar ist, mit print() ausgibt.\nRoulette: Schreiben Sie ein Programm, dass für eine Zahl prüft, ob diese im Wertebereich des Spieltischs liegt. Falls nein, soll eine Fehlermeldung ausgegeben werden. Falls ja, soll das Programm ausgeben, ob die Zahl\n\n\ngerade oder ungerade ist,\nrot oder schwarz ist,\nniedrig (1-18) oder hoch (19-36) ist und\nim 1., 2. oder 3. Dutzend liegt.\n\n\n\n\n\nRoulette Tableau\n\n\nEuropean roulette von Betzaar.com ist lizensiert unter CC 3.0 BY-SA und verfügbar auf wikimedia.org. 2010\n\nDie Musterlösung kann Marc machen.\n\n\n\n\n\n\nMusterlösung Aufgaben Flusskontrolle\n\n\n\n\n\n\n\n\n\n \n(Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. „Datenanalyse mit Python. Schleifen und Abzweigungen.“ Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#funktionen-definieren",
    "href": "funktionen.html#funktionen-definieren",
    "title": "3  Funktionen: Grundlagen",
    "section": "3.5 Funktionen definieren",
    "text": "3.5 Funktionen definieren\nDas Definieren eigener Funktionen eröffnet vielfältige Möglichkeiten und gehören zu den mächtigsten Werkzeugen in Python:\n\nKomplexe Programme können mit einer einzigen Zeile Code aufgerufen und ausgeführt werden.\nFunktionen können praktisch beliebig oft aufgerufen werden und sind durch den Einsatz von Parametern und Methoden der Flusskontrolle gleichzeitig in der Lage, flexibel auf wechselnde Bedingungen zu reagieren.\nFunktionen machen Programmcode kürzer und lesbarer. Außerdem gint es nur eine Stelle, welche bei Änderungen angepasst werden muss.\n\neine der vielseitigsten M It’s important to note that the optional argument must always appear after any required arguments when defining the function\nusing positional Arguments\n*args wird verwendet, um eine variable Anzahl von nicht-schlüsselwortlichen Argumenten zu empfangen. Innerhalb der Funktion wird args als eine Tuple behandelt, die alle übergebenen Argumente enthält.\nusing Keyword Arguments in Python\n**kwargs ist ähnlich wie *args, aber es wird verwendet, um eine variable Anzahl von schlüsselwortbasierten Argumenten zu empfangen. Innerhalb der Funktion wird kwargs als ein Dictionary behandelt.\nKeyword arguments allow developers to specify which arguments should have which values when calling a Python function. This is especially useful if order isn’t important. To use keyword arguments, pass in a dictionary with the keyword and its associated value as an argument. For example:\nmy_dict = {“optional_arg1”: 42} func_name(required_arg1, required_arg2, **my_dict)\nAusgabe: return-statement\n\nKontrollstrukturen\n\nFallunterscheidung if\n\n\nSchleifen while, for\n\n\n\nlambda",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#mapping-types",
    "href": "sammeltypen.html#mapping-types",
    "title": "4  Sammeltypen",
    "section": "4.7 Mapping Types",
    "text": "4.7 Mapping Types\nhttps://docs.python.org/3/library/stdtypes.html#mapping-types-dict",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "string-methods.html",
    "href": "string-methods.html",
    "title": "5  String Methods",
    "section": "",
    "text": "https://docs.python.org/3/library/stdtypes.html\nVon unschätzbaren Wert beim Einlesen von Datensätzen (Querverweis auf m-EsD) str.replace(old, new, count=-1) # wird new als ’’ übergeben, entspricht die Funktion dem Löschen von Zeichenfolgen\nstr.split(), str.rsplit(), str.splitlines(keepends=False)\nnicht von mir verwendet, aber nützlich:\nstr.count(sub[, start[, end]]) str.find(sub[, start[, end]]) # return the lowest index in the string where substring sub is foun str.index(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found. str.rfind(sub[, start[, end]]) # return the highest index in the string where substring sub is foun str.rindex(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found.\nstr.join(iterable) # das nutze ich einmal im m-EsD (glaube ich)\nstr.lstrip([chars]), str.rstrip([chars]), str.strip([chars]) –&gt; default ist whitespace",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>String Methods</span>"
    ]
  },
  {
    "objectID": "funktionen-definieren.html",
    "href": "funktionen-definieren.html",
    "title": "5  Funktionen definieren",
    "section": "",
    "text": "5.1 Lambdas\nhttps://docs.python.org/3/reference/expressions.html#lambda",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#unterschied-zu-sequenzen",
    "href": "sammeltypen.html#unterschied-zu-sequenzen",
    "title": "4  Sammeltypen",
    "section": "4.5 Unterschied zu Sequenzen",
    "text": "4.5 Unterschied zu Sequenzen\nhttps://docs.python.org/3/library/stdtypes.html#typesseq Sequence Types — list, tuple, range\nHinweis: Strings sind in Python eine Sequenz von Zeichen (Zeichenfolge), die unveränderlich ist (immutable). Bei der Arbeit mit strings fällt das nicht unbedingt auf. Beispiel ergänzen, bei dem ein string verändert wird. Tatsächlich wird aber immer ein neuer string angelegt.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#slicing",
    "href": "sammeltypen.html#slicing",
    "title": "4  Sammeltypen",
    "section": "4.6 Slicing",
    "text": "4.6 Slicing\nUm auf Elemente einer Zeichenfolge zuzugreifen, wird der Slicing-Operator [] verwendet.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#tupel",
    "href": "sammeltypen.html#tupel",
    "title": "4  Sammeltypen",
    "section": "4.3 Tupel",
    "text": "4.3 Tupel\nwie Simone… Listen sehr ähnlich… weil zu Listen muss man so viel sagen.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#zugriff-auf-sammeltypen",
    "href": "sammeltypen.html#zugriff-auf-sammeltypen",
    "title": "4  Sammeltypen",
    "section": "4.4 Zugriff auf Sammeltypen",
    "text": "4.4 Zugriff auf Sammeltypen\n\nSlicing-Operator []\n[:] legt eine Kopie an\n\n\n\nSammeltypen & for-Schleifen –&gt; es handelt sich um eine foreach-Schleife, die ohne Zähler auskommt und die Liste, das Tupel, die Menge oder das Dictionary (Ausgabe der keys)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#slicing-der-zugriffsoperator",
    "href": "sammeltypen.html#slicing-der-zugriffsoperator",
    "title": "4  Sammeltypen",
    "section": "4.2 Slicing: der Zugriffsoperator []",
    "text": "4.2 Slicing: der Zugriffsoperator []\nDer Zugriff auf einzelne oder mehrere Elemente einer Liste (und anderen Sammeltypen) erfolgt über den Zugriffsoperator []. Ein Ausschnitt aus einem Objekt wird Slice genannt, der Operator heißt deshalb auch Slice Operator.\n\nZugriff auf einzelne Elemente\nElemente über ihren Index, bei 0 beginnend angesprochen.\n\nprint(liste1)\nprint(liste1[0])\nprint(liste1[3])\n\n[1, 'xy', True, 'abc']\n1\nabc\n\n\nAuf verschachtelte Listen kann mit zwei aufeinanderfolgenden Zugriffsoperatoren zugegriffen werden. Die Liste liste2 enthält an Indexposition 1 eine Liste mit 4 Elementen.\n\nprint(liste2)\nprint(liste2[1])\nprint(liste2[1][0], liste2[1][1], liste2[1][2], liste2[1][3])\n\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc']\n1 xy True abc\n\n\nMit negativen Indizes können Elemente vom Ende aus angesprochen werden. So entspricht z. B. die -1 dem letzten Element.\n\nprint(liste1)\nprint(liste1[-1], liste1[-3])\n\n[1, 'xy', True, 'abc']\nabc xy\n\n\n\n\nZugriff auf mehrere Elemente\nIndexbereiche können in der Form [start:stop:step] angesprochen werden. start ist das erste adressierte Element, stop das erste nicht mehr adressierte Element und step die Schrittweite.\nvon start bis nicht einschließlich stop mit der Schrittweite step.\nSchöne Zusammenstellung der Parameter\nhttps://stackoverflow.com/questions/509211/how-slicing-in-python-works Direktlink: https://stackoverflow.com/a/509295 a[start:stop] # items start through stop-1 a[start:] # items start through the rest of the array a[:stop] # items from the beginning through stop-1 a[:] # a copy of the whole array There is also the step value, which can be used with any of the above: a[start:stop:step] # start through not past stop, by step The key point to remember is that the :stop value represents the first value that is not in the selected slice. So, the difference between stop and start is the number of elements selected (if step is 1, the default). The other feature is that start or stop may be a negative number, which means it counts from the end of the array instead of the beginning. So: a[-1] # last item in the array a[-2:] # last two items in the array a[:-2] # everything except the last two items Similarly, step may be a negative number: a[::-1] # all items in the array, reversed a[1::-1] # the first two items, reversed a[:-3:-1] # the last two items, reversed a[-3::-1] # everything except the last two items, reversed",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sammeltypen</span>"
    ]
  }
]