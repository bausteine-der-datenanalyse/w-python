# Sammeltypen
Sammeltypen werden benutzt, um mehrere Werte in einer Variablen zu speichern und zu verarbeiten. In Python gibt es vier Sammeltypen, die jeweils eine eigene Klasse sind:

  - [Listen](https://de.wikipedia.org/wiki/Liste_(Datenstruktur))

  - [Tupel](https://de.wikipedia.org/wiki/Tupel_%28Informatik%29)

  - [Mengen](https://de.wikipedia.org/wiki/Menge_%28Datenstruktur%29)

  - [assoziative Arrays](https://de.wikipedia.org/wiki/Zuordnungstabelle_%28Datenstruktur%29) oder Dictionary

**Dieses Kapitel leidet an den Ausnahmen: geteilter Speicherbereich (betrifft Listen und Dictionaries), Zugriffsoperator nicht für Mengen definiert, Methode `.copy()` nicht für Tupel definiert.**

## Listen
Listen können eine flexible Anzahl von Elementen beliebigen Typs beinhalten. In Python enthalten Listen nicht wirklich Daten, sondern bestehen aus Zeigern auf die Speicherorte der enthaltenen Elemente. Bei der Definition einer Liste, werden die Elemente durch `[]` eingeklammert und mit Kommata `,` getrennt.

```{python}
text_variable = 'abc'

liste1 = [1, 'xy', True, text_variable]
print(liste1)

# Listen können auch Listen enthalten
liste2 = [None, liste1]
print(liste2)
```

Wie alle Typen in Python, werden Listen durch Zuweisung erstellt. Eine leere Liste kann durch Zuweisung von `[]` erstellt werden.

```{python}
leere_liste = []
print(leere_liste)
```

Wie Zeichenfolgen können Listen durch den Operator '+' verkettet werden.

```{python}
verkettete_liste = liste1 + liste2
print(verkettete_liste)
```

## Slicing: der Zugriffsoperator []
Der Zugriff auf einzelne oder mehrere Elemente einer Liste (und andere Sammeltypen) erfolgt über den Zugriffsoperator []. Ein Ausschnitt aus einem Objekt wird Slice genannt, der Operator heißt deshalb auch Slice Operator.

### Zugriff auf einzelne Elemente
Elemente über ihren Index, bei 0 beginnend angesprochen.

```{python}
print(liste1)
print(liste1[0])
print(liste1[3])
```

Auf verschachtelte Listen kann mit zwei aufeinanderfolgenden Zugriffsoperatoren zugegriffen werden. Die Liste `liste2` enthält an Indexposition 1 eine Liste mit 4 Elementen.

```{python}
print(liste2)
print(liste2[1])
print(liste2[1][0], liste2[1][1], liste2[1][2], liste2[1][3])

```

Mit negativen Indizes können Elemente vom Ende aus angesprochen werden. So entspricht z. B. die -1 dem letzten Element.

```{python}
print(liste1)
print(liste1[-1], liste1[-3])
```

### Zugriff auf mehrere Elemente
Indexbereiche können in der Form `[start:stop:step]` angesprochen werden. `start` ist das erste adressierte Element, `stop` **das erste nicht mehr adressierte Element** und `step` die Schrittweite.

| Zugriffsoperator | Ausschnitt |
|---|---|
| liste[start:stop] | Elemente von start bis stop - 1 |
| liste[:] | Alle Elemente der Liste (entspricht einer Kopie) |
| liste[start:] | Elemente von start bis zum Ende der Liste |
| liste[:stop] | Elemente vom Anfang der Liste bis stop - 1 |
| liste[::3] | Auswahl jedes dritten Elements |

&nbsp;

Negative Werte für `start`, `stop` oder'step' bewirken eine Rückwärtsauswahl von Elementen.

| Zugriffsoperator | Ausschnitt |
|---|---|
| liste[-1] | das letzte Element der Liste |
| liste[-2:] | die letzten beiden Elemente der Liste |
| liste[:-2] | alle bis auf die beiden letzten Elemente |
| liste[::-1] | alle Elemente in umgekehrter Reihenfolge |
| liste[1::-1] | die ersten beiden Elemente in umgekehrter Reihenfolge |
| liste[:-3:-1] | die letzten beiden Elemente in umgekehrter Reihenfolge |
| liste[-3::-1] | alle außer die letzten beiden Elemente in umgekehrter Reihenfolge |

&nbsp;

(Beispiele von Greg Hewgill unter der Lizenz [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.de) verfügbar auf [stackoverflow](https://stackoverflow.com/a/509295). 2009)

### Kopieren von Listen
In Python werden Listen nicht durch Zuweisung kopiert, sondern greifen dann auf den selben Speicherort zu. Um eine Liste zu kopieren und ein neues Objekt im Speicher anzulegen, kann die Methode `liste.copy()` verwendet werden. Auch durch die Verwendung des Zugriffsoperators `[:]` wird eine neue Liste im Speicher angelegt.

```{python}
# Kopieren durch Zuweisung
liste1 = [1, 'xy', True, text_variable]
print("liste1:", liste1, "\n")
liste2 = liste1

## Ändern eines Elements in liste2
liste2[0] = 'ABC'
print("Auch liste1 hat sich durch die Zuweisung in liste2 verändert:", liste1, "\n")

# Verwendung der Methode liste.copy()
liste1 = [1, 'xy', True, text_variable]
liste2 = liste1.copy()
liste2[0] = 'ABC'
print("liste1 bleibt durch die Zuweisung in liste2 unverändert:", liste1, "\n")

# Verwendung des Slice Operators
liste1 = [1, 'xy', True, text_variable]
liste2 = liste1[:]

## Ändern eines Elements in liste2
liste2[0] = 'ABC'
print("liste1 bleibt durch die Zuweisung in liste2 unverändert:", liste1)
```

Die Kopie von Listenelementen ist in dieser Hinsicht unproblematisch.

```{python}
# Verwendung des Slice Operators
liste1 = [1, 'xy', True, text_variable]
liste2 = liste1[0:2]

# Ändern eines Elements in liste2
liste2[0] = 'ABC'
print("liste1 bleibt durch die Zuweisung in liste2 unverändert:", liste1)
```

Um zu überprüfen, ob sich zwei Objekte den Speicherbereich teilen, kann die Objekt-ID mit der Funktion `id()` verglichen oder die Operatoren `is` bzw. `is not` verwendet werden, die die Funktion `id()` aufrufen.

```{python}
liste1 = [1, 'xy', True, text_variable]
liste2 = liste1

print("ID liste1:", id(liste1))
print("ID liste2:", id(liste2))
print("ID liste1 gleich ID list2:", liste1 is liste2)
```

#### Identität vs. Wertgleichheit
Der Operator `is` prüft die Identität zweier Objekte und unterscheidet sich dadurch vom logischen Operator `==`, der auf Wertgleichheit prüft. Da liste1 und liste2 die gleichen Elemente enthalten, liegen sowohl Identität und Wertgleichheit vor. Der Unterschied von Identität und Wertgleichheit kann anhand eines Werts oder einer Variablen demonstriert werden (Im Code-Beispiel wird eine Syntax-Warnung unterdrückt.).

```{python}
#| warning: false

# Wertgleichheit
print(1 == 1.0)

# Identität
print(1 is 1.0)
```

## Tupel
Tupel sind Listen sehr ähnlich, jedoch sind Tupel unveränderbare Datenobjekte und können ihre Form, also ihre Länge, nicht ändern. Das bedeutet, dass zu einem existierenden Tupel keine weiteren Elemente hinzugefügt werden können. Auch können bestehende Elemente nicht geändert werden. 

Tupel werdem mit runden Klammern `()` erzeugt, die Elemente werden mit einem Komma `,` getrennt.

```{python}
tupel1 = (2, 7.8, 'Feuer', True, text_variable)
print(tupel1)
print(tupel1[2:4])
print(tupel1[::2])
print(tupel1[-1])
```

Der Zugriff auf Elemente eines Tupels erfolgt mit dem Zugriffsoperator `[]`.

```{python}
print(tupel1[::2])
```

### Tupel kopieren
Tupel verhalten sich beim Kopieren gegensätzlich zu Listen. Für Tupel ist die Methode `.copy()` nicht definiert. Tupel (bzw. die in diesen gespeicherten Werte) können durch Zuweisung kopiert werden. Dagegen bewirkt die Kopie mittels dem Zugriffsoperator `[:]` zwar, dass zwei Tupel auf den selben Speicherplatz zugreifen. Bei der Neuzuweisung eines Tupels legt Python jedoch ein neues Objekt im Speicher an.

```{python}
# Kopieren durch Zuweisung
tupel1 = (1, 2, 3)
tupel2 = tupel1

## Neuzuweisung der Werte von tupel1
tupel1 = (4, 5, 6)
print(f"Die in tupel2 gespeicherten Werte sind unverändert:\n{tupel1} {tupel2}\n")

# Kopieren mit Slice Operator
tupel1 = (1, 2, 3)
tupel2 = tupel1[:]
print(tupel2 is tupel1)

## Neuzuweisung der Werte von tupel1
tupel1 = (4, 5, 6)
print(tupel1, tupel2)
```

## Mengen
Eine Menge ist eine Sammlung von Werten, welche zum einen ungeordnet ist und zum anderen jedes Element nur einmal enthält. Es können nur unveränderbare Datenobjekte Teil einer Menge sein.

In Python können Mengen mit der `set()` Funktion z. B. aus einer Liste oder aus einem Tupel erzeugt oder durch geschweiften Klammern `{}` erstellt werden (eine leere Menge kann nur mit `set()` erzeugt werden, da `{}` ein leeres Dictionary anlegt).

```{python}
liste = [1, 1, 5, 3, 3, 4, 2, 'a', 123, 1000, ('tupel', 5)]
print("Das Objekt liste als Menge:\n", set(liste))

menge = {1, 2, 3, 4, 5, 1000, ('tupel', 5), 'a', 123}
print("Die Menge kann auch mit geschweiften Klammern erzeugt werden:", menge)
```

Mengen können beispielsweise für Vergleichsoperationen verwendet werden.

```{python}

menge_a = set('Python')
menge_b = set('ist super')

# einzigartige Zeichen in a
print("Menge a:", menge_a)

# Zeichen in a, aber nicht in b
print("Menge a - b:", menge_a - menge_b)

# Zeichen in a oder b
print("Menge a | b:", menge_a | menge_b)

# Zeichen in a und b
print("Menge a & b:", menge_a & menge_b)

# Zeichen in a oder b, aber nicht in beiden (XOR)
print("Menge a ^ b:", menge_a ^ menge_b)
```

### Mengen kopieren
Mengen verhalten sich wie Tupel mit dem Unterschied, dass die Methode `.copy()` für Mengen definiert ist (**der Zugriffsoperator `[:]` kann jedoch nicht auf Mengen angewendet werden**).

```{python}
# Kopieren durch Zuweisung
set1 = {1, 2, 3}
set2 = set1
print(set1 is set2)

## Neuzuweisen von set1
set1 = {4, 5, 6}
print(f"Die in set2 gespeicherten Werte sind unverändert:\n{set1} {set2}")

# Kopieren durch Methode .copy()
set1 = {1, 2, 3}
set2 = set1.copy()
print(set1 is set2)


## Neuzuweisen von set1
set1 = {4, 5, 6}
print(f"Die in set2 gespeicherten Werte sind unverändert:\n{set1} {set2}")

```

## Dictionaries
Dictionaries sind Zuordnungstabellen, d. h. sie bestehen aus Schlüssel-Wert-Paaren. Die Schlüssel können Zahlen oder Zeichenketten sein. Dictionaries werden mit geschweiften Klammern `{}` definiert. Die Schlüssel und deren zugehörigen Werte werden mit einem Doppelpunkt `:` getrennt. Der Zugriff auf die Werte erfolgt mit dem Zugriffsoperator `[]`, welcher den oder die Schlüssel beinhaltet.

```{python}
dictionary = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}
print(dictionary, "\n")

print("Werte des Schlüssels 1:", dictionary[1])
print("Werte des Schlüssels 'b':",  dictionary['b'])
```

Auf die Schlüssel eines Dictionaries kann über die Methode `dictionary.keys()`, auf die Werte mittels der Methode `dictionary.values()` zugegriffen werden. 

```{python}
print("Schlüssel:", dictionary.keys(), "\n")
print("Werte:", dictionary.values())
```

### Dictionaries kopieren
**sollten sich wie Listen verhalten**

## Arbeiten mit Sammeltypen
**text**

### del-Operator

### Schleifen
Sammeltypen & for-Schleifen --> es handelt sich um eine foreach-Schleife, die ohne Zähler auskommt und die Liste, das Tupel, die Menge oder das Dictionary (Ausgabe der keys)

### Umwandeln von Sammeltypen
Damit kann man die Sammeltypen auch erzeugen.
list()
  `list(dictionary)` gibt die Schlüssel eines Dictionaries zurück
tuple()
dict() # hier ist die Syntax anders 
set()

## Unterschied zu Sequenzen
https://docs.python.org/3/library/stdtypes.html#typesseq
Sequence Types — list, tuple, range

Hinweis: Strings sind in Python eine Sequenz von Zeichen (Zeichenfolge), die unveränderlich ist (immutable). Bei der Arbeit mit strings fällt das nicht unbedingt auf. **Beispiel ergänzen, bei dem ein string verändert wird.** Tatsächlich wird aber immer ein neuer string angelegt.
  
## Slicing
Um auf Elemente einer Zeichenfolge zuzugreifen, wird der Slicing-Operator `[]` verwendet. 

## Mapping Types
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict

# Aufgabe Listen und Sammeltypen
1. Bubble Sort - dafür braucht man Listen und Slicing 

(@Arnold-2023-schleifen-abzweigungen)