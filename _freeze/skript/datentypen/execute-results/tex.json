{
  "hash": "f194ec7ca02a3a30ca97f54e119a877f",
  "result": {
    "engine": "jupyter",
    "markdown": "# Datentypen\nObjekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt an, wie die gespeicherten Werte von Python interpretiert werden sollen. Beispielsweise kann der Wert \"1\" in Python ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar, den Wochentag Dienstag oder die Auspr√§gung einer kategorialen Variablen repr√§sentieren.\n\nIn diesem Abschnitt werden die f√ºr die Datenanalyse wichtigsten Datentypen vorgestellt.\n\n## Zahlen\nZu den Zahlen geh√∂ren Ganzzahlen, boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen (die hier nicht n√§her vorgestellt werden).\n\n### Ganzzahlen\nGanzzahlen werden standardm√§√üig im Dezimalsystem eingegeben und k√∂nnen positiv oder negativ sein.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nprint(12, -8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12 -8\n```\n:::\n:::\n\n\nDar√ºber hinaus k√∂nnen Ganzzahlen auch in anderen Basen angegeben werden:\n\n* Dualsystem: Ziffern `0` und `1` mit dem Pr√§fix `0b` \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8 plus 0 plus 2 plus 1 ist 11\n```\n:::\n:::\n\n\n* Oktalsystem: Ziffern `0` bis `7` mit dem Pr√§fix `0o` \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3584 plus 448 plus 16 plus 0 ist 4048\n```\n:::\n:::\n\n\n* Hexadezimalsystem: Ziffern `0` bis `F` mit dem Pr√§fix `0x`\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n61440 plus 512 plus 160 plus 1 ist 62113\n```\n:::\n:::\n\n\n### Gleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen `.` oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ `float`.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-3, \"oder\", 1e+3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n0.001 oder 1000.0\n```\n:::\n:::\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 1~2~ durch 1010~2~ aber ein periodischer Bruch:\n$$ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 $$\n\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch, der 0.1 ann√§hert, ist in Dezimalschreibweise 3602879701896397 / 2^55^). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der [Python Dokumentation](https://docs.python.org/3/tutorial/floatingpoint.html)). \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.1\n0.10000000000000001\n0.09999999999999998\n```\n:::\n:::\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n```\n:::\n:::\n\n\n## Arithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ `float`, au√üer, wenn beide Operanden vom Typ `int` sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n| Operator | Beschreibung |\n| :--: | :--: |\n| `+`, `-` |  Addition / Subtraktion |\n| `*`, `/` | Multiplikation / Division |\n| `//`, `%` | Ganzzahlige Division / Rest | \n| `**`| Potenzieren |\n\n&nbsp;\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern `(1 + 2) * 3` hergestellt werden. Es gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der [Pythondokumentation](https://docs.python.org/3/reference/expressions.html#operator-precedence) aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n| Operator |\n| :--: |\n| `**` |\n| `*` , `/` , `//` , `%` |\n| `+` , `-` |\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.\n\n## Aufgaben Zahlen\n**L√∂sen Sie die folgenden Aufgaben mit Python.**\n\n1. 4 + 2 * 4 = ?\n2. 2 hoch 12 = ?\n3. Was ist der Rest aus 315 geteilt durch 4?\n4. ùü£ + ùü§<sup>6</sup> / ùüß = ?\n5. Welche Dezimalzahl ist 11111101001~2~ ?\n6. 11111101001~2~ / 101~2~ = ?\n7. Welcher Kapitalertrag ist gr√∂√üer, wenn 1000 Euro angelegt werden?\n\n    a) 20 Jahre Anlagedauer mit 3 Prozent j√§hrlicher Rendite\n\n    b) 30 Jahre Anlagedauer mit 2 Prozent j√§hrlicher Rendite\n\n**Die Musterl√∂sung kann Marc machen.**\n\n::: {#tip-l√∂sungzahlen .callout-tip collapse=\"true\"}\n## Musterl√∂sung Zahlen\n:::\n\n## Boolsche Werte\nDie boolschen Werte `True` und `False` sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte `1` und `0` an und geh√∂ren in Python deshalb zu den Zahlen.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 > 9)\nprint(\"Ist 11 kleiner als 10?\", 11 < 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n```\n:::\n:::\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprint(\"Ist 10 > 9 UND 10 > 8?\", (10 > 9) * (10 > 8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIst 10 > 9 UND 10 > 8? 1\n```\n:::\n:::\n\n\nDie Funktion `bool()` gibt den Wahrheitswert eines Werts zur√ºck.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nprint(\"Ist 10 > 9 UND > 8?\", bool((10 > 9) * (10 > 8)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIst 10 > 9 UND > 8? True\n```\n:::\n:::\n\n\nDie meisten Werte in Python haben den Wahrheitswert `True`.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue True True\nTrue True True\n```\n:::\n:::\n\n\nNeben `False` und `0` haben leere und nicht existierende Werte oder Objekte den Wahrheitswert `False`.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n```\n:::\n:::\n\n\nDie Sammeltypen Liste, Tupel und Dictionary lernen wir in den folgenden Kapiteln kennen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie `an` und `aus` wirken. So kann Programmcode mit einer `if`-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n```\n:::\n:::\n\n\n## Logische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen `and`, `or` und `not`. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie `>`, `>=` oder `==` verwendet werden. Das Ergebnis dieser Operationen ist vom Typ `bool`. Die Operatoren werden in folgender Reihenfolge ausgef√ºhrt. Gleichrangige Operatoren werden von links nach rechts ausgef√ºhrt.\n\n| Operator | Beschreibung |\n| :--: | :--: |\n| `&` | bitweises UND |\n| `^` | bitweises XOR |\n| `|` | bitweises ODER |\n| `<`, `<=`, `>`,  `>=`, `!=`, `==` | kleiner / kleiner gleich / gr√∂√üer als /  gr√∂√üer gleich / ungleich / gleich |\n| `not` | logisches NICHT |\n| `and`| logisches UND |\n| `or` | logisches ODER |\n\n::: {#wrn-bitwise .callout-warning appearance=\"simple\" collapse=\"false\"}\n## Bitweise Operatoren\nBesondere Vorsicht ist mit den [bitweisen Operatoren](https://wiki.python.org/moin/BitwiseOperators) geboten. Diese vergleichen Zahlen nicht als Ganzes, sondern stellenweise (im Bin√§rsystem). Zu beachten ist, dass die bitweisen Operatoren  Ausf√ºhrungspriorit√§t vor Vergleichsoperationen haben.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nprint(10 > 5 and 10 > 6)\nprint(10 > 5 & 10 > 6)\nprint(5 & 10)\nprint(10 > False > 6)\nprint((10 > 5) & (10 > 6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\n0\nFalse\nTrue\n```\n:::\n:::\n\n\n:::: {.callout-tip collapse=\"false\"}\nIm Allgemeinen werden die bitweisen Operatoren f√ºr die Datenanalyse nicht ben√∂tigt. Vermeiden Sie unn√∂tige Fehler: Vermeiden Sie die bitweisen Operatoren `&`, `^` und `|`.\n\nDie Operatoren `&`, `^` und `|` haben jedoch f√ºr Mengen (die wir sp√§ter kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der √úbergabe mehrerer Slicing-Bedingungen `df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)]`.\n\n::::\n:::\n\n## Aufgaben boolsche Werte\n**L√∂sen Sie die Aufgaben mit Python.**\n\n1. Ist das Verh√§ltnis aus 44 zu 4.5 gr√∂√üer als 10?\n2. Ist es wahr, dass 4.5 gr√∂√üer als 4 aber kleiner als 5 ist?\n3. Ist 2 hoch 10 gleich 1024?\n4. Sind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\n5. Pr√ºfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.  \nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n**Die Musterl√∂sung kann Marc machen**\n\n::: {#tip-musterl√∂sung-bool .callout-tip collapse=\"true\"}\n\n:::\n\n## Zeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anf√ºhrungszeichen gesetzt.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nprint('eine Zeichenfolge')\nprint(\"noch eine Zeichenfolge\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neine Zeichenfolge\nnoch eine Zeichenfolge\n```\n:::\n:::\n\n\nInnerhalb einer Zeichenfolge k√∂nnen einfache oder doppelte Anf√ºhrungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschlie√üenden Anf√ºhrungszeichen entsprechen.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n```\n:::\n:::\n\n\nDas Steuerzeichen `\\` (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden. \n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nprint(\"Das Steuerzeichen \\\\ erm√∂glicht die gleichen \\\"Anf√ºhrungszeichen\\\" in der Ausgabe von print.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDas Steuerzeichen \\ erm√∂glicht die gleichen \"Anf√ºhrungszeichen\" in der Ausgabe von print.\nErst ein\tTabstopp, dann eine\nneue Zeile.\n```\n:::\n:::\n\n\nEin vorangestelltes `r` bewirkt, dass das Steuerzeichen `\\` nicht verarbeitet wird (raw string literal). Dies ist beispielsweise bei der Arbeit mit Dateipfaden praktisch.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nprint(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\nprint(r\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDie Daten liegen unter: C:\tolle_daten\nordpol\\weihnachtsmann\nDie Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\n```\n:::\n:::\n\n\n## Operationen mit Zeichenfolgen\nEinige Operatoren funktionieren auch mit Daten vom Typ string.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# string + string\nprint('a' + 'b')\n\n# string + Zahl\nprint(15 * 'a')\n\n# logische Operatoren\nprint('a' < 'b', 'a' >= 'b', 'a' != 'b')\nprint('a' or 'b', 'a' and 'b')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nab\naaaaaaaaaaaaaaa\nTrue False True\na b\n```\n:::\n:::\n\n\n## Aufgaben Zeichenfolgen\n**L√∂sen Sie die Aufgaben mit Python.**\n\n1. Was passiert, wenn Sie die Zeichenfolge \"Python\" mit \"for beginners\" addieren?\n2. Erzeugen Sie eine Zeichenfolge, die 10 mal die Zeichenfolge \"tick tack\".\n3. Welche Zeichenfolge ist kleiner, \"Aachen\" oder \"Bern\". Warum ist das so, wie werden Zeichenfolgen verglichen?\n4. Geben Sie den Dateipfad aus: \"~\\\\home\\\\tobi\\\\neue_daten\"\n\n**Die Musterl√∂sung kann Marc machen.**\n\n::: {#tip-l√∂sungstrings .callout-tip collapse=\"true\"}\n## Musterl√∂sung Aufgaben Zeichenfolgen\n\n::: \n\n## Variablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator `=` dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDas ABC hat 26 Buchstaben. Das ist True\n```\n:::\n:::\n\n\nVariablen m√ºssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDie Variable var_1 hat den Typ <class 'str'>\nDie Variable var_2 hat den Typ <class 'int'>\nDie Variable var_3 hat den Typ <class 'bool'>\n```\n:::\n:::\n\n\nDer Datentyp einer Variable √§ndert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDie Variable var_1 hat den Typ <class 'int'>\n```\n:::\n:::\n\n\nEbenso kann sich der Datentyp einer Variable √§ndern, um das Ergebnis einer Operation aufnehmen zu k√∂nnen. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp 'float' zu. \n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDie Variable var_1 hat den Typ <class 'float'>\n```\n:::\n:::\n\n\nPython enth√§lt Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion `type()` wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Flie√ükommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n67 <class 'int'>\n68.8 <class 'float'> \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Flie√ükommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n```\n:::\n:::\n\n\n### Weitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte [Walross-Operator](https://docs.python.org/3/whatsnew/3.8.html) `:=` verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion `print()`) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe [Python-Dokumentation](https://docs.python.org/3/reference/simple_stmts.html) oder √ºbersichtlicher [hier](https://www.w3schools.com/python/python_operators.asp)).\n\n| Operator | entspricht der Zuweisung |\n|---|---|\n| a += 2 | a = a + 2 |\n| a -= 2 | a = a - 2 |\n| a *= 2 | a = a * 2 |\n| a /= 2 | a = a / 2 |\n| a %= 2 | a = a % 2 |\n| a //= 2 | a = a // 2 |\n| a **= 2 | a = a ** 2 |\n\n::: {.callout-tip collapse=\"false\"}\n## Lesbare Zuweisungen\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind f√ºr jemanden, der*die Ihren Code liest, gut zu lesen und  nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\n\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag f√ºr Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abtr√§glich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n:::\n\n### Benennung von Variablen\nF√ºr die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausf√ºhrlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben l√§sst. Denn Programmcode wird deutlich h√§ufiger gelesen als geschrieben. K√∂nnen Sie sich erinnern? Welcher Wert ist in der Variablen `Var_3` gespeichert, und welche Werte sind in `variable1` und `a` gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern k√∂nnen.\n\nFalls Sie sich nicht erinnern k√∂nnen, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Aufl√∂sung steht im folgenden Aufklapper.\n\n::: {.callout-tip collapse=\"true\"}\n## Aufl√∂sung Variablen\n\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nprint(var_3, type(var_3))\nprint(variable1, type(variable1))\nprint(a, type(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue <class 'bool'>\n15 <class 'int'>\n67.0 <class 'str'>\n```\n:::\n:::\n\n\n:::\n\nDeshalb empfiehlt es sich \"sprechende\", das hei√üt selbsterkl√§rende, Variablennamen zu vergeben. Unter selbsterkl√§renden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit `academic_degree` oder `studienabschluss` bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einflie√üen, etwa: `academic_degree_2023` oder `studienabschluss2024`. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in [diesem Wikipedia Abschnitt](https://de.wikipedia.org/wiki/Variable_(Programmierung)#Namenswahl). \n\n\n::: {.callout-warning}\n## Schl√ºsselw√∂rter und Funktionsnamen\n\nIn Python reservierte Schl√ºsselw√∂rter und Funktionsnamen sind ungeeignete Variablennamen. W√§hrend Python die Wertzuweisung zu Schl√ºsselw√∂rtern wie `True` oder `break` mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen neue Werte zuweisen, beispielsweise mit `print = 6`. Wenn Sie die Funktion print dann aufrufen, funktioniert diese nat√ºrlich nicht mehr. In diesem Fall m√ºssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\nFolgende Schl√ºsselw√∂rter gibt es in Python:\n\n```\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\nawait      else       import     pass       True\nbreak      except     in         raise      class\nFalse      finally    is         return     None\n```\n\n:::\n\n## Aufgaben Variablen\n1. Schreiben Sie ein Skript, welches eine gegebene Zeit ùóç in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.  \nBerechnen Sie die Aufteilung f√ºr folgende Zeiten:\n\n    a) 79222 s\n  \n    b) 90061 s\n  \n    c) 300000 s\n\n2. Die Position eines Fahrzeugs zur Zeit $t$, welches konstant mit der Beschleunigung $a$ beschleunigt, ist gegeben durch:\n\n$$\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n$$\n\nDabei ist $x_0$ die Anfangsposition und $v_0$ die Anfangsgeschwindigkeit. Erstellen Sie Variablen f√ºr $x_0$, $v_0$ und $a$ und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, √ºberlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte k√∂nnen sie als Beispiel verwenden:\n\n$$\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n$$\n\nErzeugen Sie eine Variable f√ºr den Zeitpunkt $t$, z. B.: $t = 10 \\, min$.\nBerechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position $x(t)$.\nGeben Sie nicht nur den Wert von $x(t)$ in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschlie√ülich Einheiten) ein.\n\n**Die Musterl√∂sung kann Marc machen.**\n\n::: {#tip-l√∂sungvariablen .callout-tip collapse=\"true\"}\n## Musterl√∂sung Aufgaben Variablen\n\n:::\n\n[@Arnold-2023-datentypen-und-grundlagen]\n\n[@Arnold-2023-funktionen-module-dateien]\n\n",
    "supporting": [
      "datentypen_files/figure-pdf"
    ],
    "filters": []
  }
}