{
  "hash": "e6dfc78a8a85fed5274e278c6c7c1bf1",
  "result": {
    "engine": "jupyter",
    "markdown": "# Eigene Funktionen definieren\nDas Definieren eigener Funktionen eröffnet vielfältige Möglichkeiten in Python:\n\n  - Komplexe Programme können mit einer einzigen Zeile Code aufgerufen und ausgeführt werden.\n\n  - Funktionen können praktisch beliebig oft aufgerufen werden und sind durch den Einsatz von Parametern und Methoden der Flusskontrolle gleichzeitig in der Lage, flexibel auf wechselnde Bedingungen zu reagieren.\n\n  - Funktionen machen Programmcode kürzer und lesbarer. Außerdem gibt es nur eine Stelle, welche bei Änderungen angepasst werden muss.\n\n## Syntax\nDas Schlüsselwort `def` leitet die Funktionsdefinition ein. Es wird gefolgt vom Funktionsnamen und den Funktionsparametern, welche in runden Klammern `()` eingeschlossen sind. Der Funktionskopf wird mit einem Doppelpunkt `:` beendet. Der Anweisungsblock der Funktion ist eingerückt. Jede Funktion liefert einen Rückgabewert, welche durch das Schlüsselwort `return` an die aufrufende Stelle zurückgegeben wird.  `return` beendet die Ausführung der Schleife, auch wenn es nicht am Ende des Anweisungsblocks steht.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef Funktionsname(Parameter1, Parameter2):\n    Anweisungsblock\n    return Rückgabewert\n```\n:::\n\n\nDamit die Funktion ausgeführt wird, muss der definierte Funktionsname aufgerufen werden. In der Funktion ist nach dem Schlüsselwort `return` eine weitere Anweisung enthalten, die nicht mehr ausgeführt wird.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Beispiel 1: Summe der Quadrate\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b):\n    print('Argument a:', a)\n    print('Argument b:', b)\n    print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n    print(\"Anweisungen nach dem Schlüsselwort return werden nicht mehr ausgeführt.\")\n\nprint(sum_quadrate(6, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArgument a: 6\nArgument b: 7\n==================\n85\n```\n:::\n:::\n\n\nDer Rückgabewert kann in einer Variablen gespeichert werden.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nergebnis = sum_quadrate(6, 7)\nprint(ergebnis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArgument a: 6\nArgument b: 7\n==================\n85\n```\n:::\n:::\n\n\n## Optionale Parameter\nMit Hilfe von optionalen Parametern kann die Programmausführung gesteuert werden. Optionale Parameter müssen nach verpflichtend zu übergebenen Parametern definiert werden. In diesem Beispiel wird die print-Ausgabe der Funktion mit dem Parameter `ausgabe` gesteuert.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Beispiel 2: optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b, ausgabe = False):\n    if ausgabe:\n      print('Wert Argument a:', a)\n      print('Wert Argument b:', b)\n      print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n\nprint(sum_quadrate(42, 7), \"\\n\")\nprint(sum_quadrate(42, 7, ausgabe = True))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1813 \n\nWert Argument a: 42\nWert Argument b: 7\n==================\n1813\n```\n:::\n:::\n\n\nGibt es mehrere optionale Parameter, so erfolgt die Zuweisung von Argumenten positional oder über das Schlüsselwort.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Beispiel 3: mehrere optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Argument a:', a)\n      print('Argument b:', b)\n      print('Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return summe\n\n# positionale Übergabe\nprint(sum_potenzen(42, 7, 3, True), \"\\n\")\n\n# Übergabe per Schlüsselwort\nprint(sum_potenzen(42, 7, ausgabe = True, p = 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArgument a: 42\nArgument b: 7\nArgument p: 3\n==================\n74431 \n\nArgument a: 42\nArgument b: 7\nArgument p: 4\n==================\n3114097\n```\n:::\n:::\n\n\n## Rückgabewert(e)\nFunktionen können in Python nur einen einzigen Rückgabewert haben. Trotzdem können mehrere Rückgabewerte mit einem Komma getrennt werden. Python gibt diese als Tupel zurück.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Beispiel 4: mehrere Rückgabewerte\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Argument a:', a)\n      print('Argument b:', b)\n      print('Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return a, b, summe\n\nergebnis = sum_potenzen(2, 7, ausgabe = False, p = 4)\nprint(ergebnis, type(ergebnis))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2, 7, 2417) <class 'tuple'>\n```\n:::\n:::\n\n\nMit dem Slice Operator kann ein bestimmter Rückgabewert ausgewählt werden.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(ergebnis[2])\n\nsumme_potenzen = sum_potenzen(2, 7, ausgabe = False, p = 4)[2]\nprint(summe_potenzen, type(summe_potenzen))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2417\n2417 <class 'int'>\n```\n:::\n:::\n\n\n<!-- ggf. ergänzen\n## anonyme Funktionen Lambdas\n<https://docs.python.org/3/reference/expressions.html#lambda> -->\n\n## Aufgaben Funktionen definieren\n1. Palindrom  \nSchreiben Sie eine Funktion is_palindrome(), die prüft, ob es sich bei einer übergebenen Zeichenkette um ein Palindrom handelt.\n\n*Hinweis: Ein Palindrom ist eine Zeichenkette, die von vorne und von hinten gelesen gleich bleibt, wie beispielsweise ‘Anna’, ‘Otto’, ‘Lagerregal’. Palindrome müssen nicht aus Buchstaben bestehen, sie können sich auch aus Zahlen oder Buchstaben und Zahlen zusammensetzen wie beispielsweise ‘345g543’.*\n\n2. Fibonacci-Zahlenreihe\n\nEntwickeln Sie eine Funktion fibonacci(n), die die ersten n Zahlen der Fibonacci-Reihe generiert und als Liste zurückgibt. Die Fibonacci-Reihe beginnt mit 0 und 1, jede weitere Zahl ist die Summe der beiden vorhergehenden Zahlen.\n\n3. Verschlüsselung\n\nBei Geocachen werden oft verschlüsselte Botschaften als Rätsel verwendet. Oft wird folgende Logik zur Verschlüsselung angewendet:\n\n* A -> Z\n\n* B -> Y\n\n* C -> X\n\n* ...\n\nSchreiben Sie eine Funktion `verschluesseln(str)`, die einen String als Eingabewert bekommt und einen verschlüsselten String zurückgibt. Wie können Sie einen verschlüsselten String am einfachsten wieder entschlüsseln?\n\n4. Temperaturkonverter\n\nEntwickeln Sie eine Funktion `temperatur_umrechnen(wert, von_einheit, nach_einheit)`, die eine Temperatur von einer Einheit in eine andere umwandelt. Die Funktion soll folgende Parameter verwenden:\n\n  - wert: Der Temperaturwert, der umgewandelt werden soll.\n  \n  - von_einheit / nach_einheit: Die Einheit des Ausgangs- bzw. des Zielwerts als string. Mögliche Werte sind 'C' für Celsius, 'F' für Fahrenheit und 'K' für Kelvin.\n\nEs gelten die folgenden Umrechnungsformeln zwischen den Einheiten:\n\n  - Celsius nach Fahrenheit: F = C * 9/5 + 32\n  \n  - Fahrenheit nach Celsius: C = (F - 32) * 5/9\n  \n  - Celsius nach Kelvin: K = C + 273.15\n  \n  - Kelvin nach Celsius: C = K - 273.15\n  \n  - Fahrenheit nach Kelvin: K = (F - 32) * 5/9 + 273.15\n  \n  - Kelvin nach Fahrenheit: F = (K - 273.15) * 9/5 + 32\n\n::: {.callout-tip collapse=\"true\"}\n## Musterlösung Aufgaben Funktionen definieren\n\n:::: {.border}\n\n1. Aufgabe Palindrom\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# 1.\ndef is_palindrome(text):\n    text = text.lower()\n\n    return text == text[::-1]\n\n# zu prüfende Zeichenkette in dieser Variablen anlegen\nxyz = \"Lagerregal\"\nif is_palindrome(xyz) == True:\n    print(f\"Ja, {xyz} ist ein Palindrom\")\nelse:\n    print(f\"Nein, {xyz} ist kein Palindrom\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJa, Lagerregal ist ein Palindrom\n```\n:::\n:::\n\n\n2. Aufgabe Fibonacci\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# 2.\ndef fibonacci(n):\n\n    # die Sonderfälle müssen beachtet werden:\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n\n    # nachdem die beiden Sonderfälle berücksichtigt wurden, sieht die Liste zum Start immer wie folgt aus:\n    fibonacci_reihe = [0,1]\n    \n    while len(fibonacci_reihe) < n:\n        naechste_zahl = fibonacci_reihe[-1] + fibonacci_reihe[-2]\n        fibonacci_reihe.append(naechste_zahl)\n    \n    return fibonacci_reihe\n\nfibonacci(8)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n[0, 1, 1, 2, 3, 5, 8, 13]\n```\n:::\n:::\n\n\n3. Aufgabe Verschlüsselung\n\n::::: {.panel-tabset}\n## mit Listen\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# 3.\ndef verschluesseln(str):\n\n    # in sechs Variablen wird einmal das normale und einmal das umgekehrte Alphabet sowie die Ziffern 0-9 definiert\n    abc = \"abcdefghijklmnopqrstuvwxyz\"\n    abc_2 = \"zyxwvutsrqponmlkjihgfedcba\"\n    ABC = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    ABC_2 = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    ziffern = \"0123456789\"\n    ziffern_2 = \"9876543210\"\n\n    neuer_string = \"\"\n\n    for i in str:\n        if i in ABC: # Großbuchstaben\n            position = ABC.index(i)\n            neuer_buchstabe = ABC_2[position]\n\n            neuer_string += neuer_buchstabe\n        elif i in abc: # Kleinbuchstaben\n            position = abc.index(i)\n            neuer_buchstabe = abc_2[position]\n\n            neuer_string += neuer_buchstabe   \n        elif i in ziffern: # Ziffern\n            position = ziffern.index(i)\n            neuer_buchstabe = ziffern_2[position]\n\n            neuer_string += neuer_buchstabe                    \n        else: # sonstige Zeichen werden unverändert übernommen\n            neuer_string += i\n    \n    return neuer_string\n    \n# zu verschlüsselnde Nachricht:\ngeheime_nachricht = 'Dies ist das Geheimnis: <*)))><'\nenkodierter_text = verschluesseln(geheime_nachricht)\nprint(enkodierter_text)\n\n# die einfachste Möglichkeit die verschlüsselte Nachricht wieder zu entschlüsseln ist, die gleiche Funktion erneut auf die verschlüsselte Nachricht anzuwenden\ndekodierter_text = verschluesseln(enkodierter_text)\nprint(dekodierter_text)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWrvh rhg wzh Tvsvrnmrh: <*)))><\nDies ist das Geheimnis: <*)))><\n```\n:::\n:::\n\n\n## mit ord() und chr()\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef verschluesseln(a):\n    a = list(a)\n    # print(a)\n    b = [] # output list\n    \n    for i in a:\n        # print(i, ord(i))\n        b.append(ord(i))\n    # print(b)\n            \n    # invertieren a = 97, z = 122, A = 65, Z = 90, 0 = 48, 9 = 57\n    # Max - Wert + Min \n    \n    for i in range(len(b)):\n        if b[i] >= 65 and b[i] <= 90: # Großbuchstaben\n            b[i] = chr(90 - b[i] + 65)\n        elif b[i] >= 97 and b[i] <= 122: # Kleinbuchstaben\n            b[i] = chr(122 - b[i] + 97)\n        elif b[i] >= 48 and b[i] <= 57: # Zahlen\n            b[i] = chr(57 - b[i] + 48) \n        else: # sonstige Zeichen\n            b[i] = chr(b[i])\n            \n    return ''.join(b)\n\nprint(enkodierter_text)\nprint(verschluesseln(a = enkodierter_text))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWrvh rhg wzh Tvsvrnmrh: <*)))><\nDies ist das Geheimnis: <*)))><\n```\n:::\n:::\n\n\n:::::\n\n4. Temperaturkonverter\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# 4.\ndef temperatur_umrechnen(wert, von_einheit, nach_einheit):\n\n    # if-Abfragen um zu prüfen, welche Einheit der umzuwandelnde Wert hat. Je nachdem welcher Zweig ausgelöst wird, wird der Wert in weiteren if-Abfragen entsprechend der Zieleinheit umgerechnet\n    \n    # if-Abfrage für Ursprungswert in Celsius:\n    if von_einheit == \"C\":\n        if nach_einheit == \"F\":\n            return wert * 9/5 + 32\n        elif nach_einheit == \"K\":\n            return wert + 273.15\n        elif nach_einheit == \"C\":\n            return wert\n    \n    # if-Abfrage für Ursprungswert in Fahrenheit:\n    if von_einheit == \"F\":\n        if nach_einheit == \"C\":\n            return (wert - 32) * 5/9\n        elif nach_einheit == \"K\":\n            return (wert - 32) * 5/9 + 273.15\n        elif nach_einheit == \"F\":\n            return wert\n    \n    # if-Abfrage für Ursprungswert in Kelvin:\n    if von_einheit == \"K\":\n        if nach_einheit == \"C\":\n            return wert - 273.15\n        elif nach_einheit == \"F\":\n            return (wert - 273.15) * 9/5 + 32\n        elif nach_einheit == \"K\":\n            return wert\n\n    # für ungültige Einheiten wird None zurückgegeben    \n    return None\n\ntest_temp = temperatur_umrechnen(37, \"C\", \"F\")\nprint(f\"37°C sind in Fahrenheit: {test_temp}°F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n37°C sind in Fahrenheit: 98.6°F\n```\n:::\n:::\n\n\nMusterlösung von Marc Sönnecken und Maik Poetzsch\n\n::::\n:::\n\n&nbsp;\n(@Arnold-2023-funktionen-module-dateien)\n\n",
    "supporting": [
      "funktionen-definieren_files/figure-pdf"
    ],
    "filters": []
  }
}